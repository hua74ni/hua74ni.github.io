<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springMVC文件上传下载及图片显示]]></title>
    <url>%2F2017%2F12%2F17%2FspringMVC%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%8F%8A%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[摘要: springMVC文件上传下载及图片显示 文件上传前端 12345&lt;form id=&quot;form1&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/shop/addShop.do&quot; &gt; 商家图片上传&lt;input type=&quot;file&quot; id=&quot;shopImage&quot; name=&quot;shopImage&quot; /&gt;&lt;br/&gt; 商家名称&lt;input type=&quot;text&quot; id=&quot;shopName&quot; name=&quot;shopName&quot; value=&quot;test123&quot; /&gt;&lt;/form&gt;&lt;br/&gt; ShopController.java 1234567891011121314@RequestMapping(&quot;/addShop.do&quot;)public String addShop(MultipartFile shopImage,Shop shop, HttpServletRequest request)&#123; User user = (User) request.getSession().getAttribute(&quot;loginUser&quot;); if(user == null)&#123; logger.error(&quot;用户未登录&quot;); &#125; shop.setShopUserId(user.getUserId()); int result = shopService.addShop(shopImage,shop); return &quot;redirect:goShopRedirect.do?result=&quot;+result;&#125; ShopService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Overridepublic int addShop(MultipartFile shopImage, Shop shop) &#123; if(shop == null || shopImage.isEmpty())&#123; return 0; &#125; //获取shop图片保存路径 String originalFilename = shopImage.getOriginalFilename(); String shopImagePath = PropertiesUtil.getString(&quot;shop.image.path&quot;); //文件名： long时间+&quot;-&quot;+源文件名 String fileName = (new Date()).getTime()/1000 + &quot;-&quot; +originalFilename; File folder = new File(shopImagePath); if (!folder.exists()) &#123; folder.mkdirs(); &#125; //将上传的图片保存到指定路径 File image = new File(shopImagePath,fileName); try &#123; shopImage.transferTo(image); shop.setShopLogoPath(fileName); &#125; catch (IOException e) &#123; logger.error(&quot;商家上传图片失败&quot;); logger.error(e.toString()); e.printStackTrace(); throw new RuntimeException(); &#125; shop.setCreateTime(new Date()); return shopMapper.insertSelective(shop);&#125;@Overridepublic int updateShop(MultipartFile shopImage, Shop shop) &#123; if(shop == null || StringUtils.isNullOrBlank(shop.getShopId()))&#123; return 0; &#125; //如果图片为空就不上传 不替代之前的图片 //如果不为空 替代之前的图片 并且删除之前的图片 if(shopImage != null &amp;&amp; !shopImage.isEmpty())&#123; String originalFilename = shopImage.getOriginalFilename(); String shopImagePath = PropertiesUtil.getString(&quot;shop.image.path&quot;); String fileName = (new Date()).getTime()/1000 + &quot;-&quot; +originalFilename; File image = new File(shopImagePath,fileName); try &#123; shopImage.transferTo(image); shop.setShopLogoPath(fileName); //获取修改之前的shop信息 Shop tmpShop = this.getShopByShopId(shop); //删除之前的图片 deleteOldImage(tmpShop.getShopLogoPath()); &#125; catch (IOException e) &#123; logger.error(&quot;商家上传图片失败&quot;); logger.error(e.toString()); throw new RuntimeException(); &#125; &#125; return shopMapper.updateByPrimaryKeySelective(shop);&#125;//删除旧的图片private void deleteOldImage(String shopLogoPath)&#123; String shopImagePath = PropertiesUtil.getString(&quot;shop.image.path&quot;); String filePath = shopImagePath + &quot;/&quot; + shopLogoPath; File file = new File(filePath); try &#123; FileUtils.forceDelete(file); &#125; catch (IOException e) &#123; logger.error(&quot;图片删除失败&quot;); e.printStackTrace(); &#125;&#125; 文件下载1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 下载对应的文件名 * * @param fileName * @param fileType * @param request * @param response * @throws Exception */@RequestMapping(value = &quot;/downloadFile.do&quot;)@ResponseBodypublic void downloadFile(String fileName, String fileType, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 通过 文件名和文件类型 获取对应的目标文件 File targetFile = getTargetFile(fileType, fileName); if (targetFile == null) &#123; logger.error(fileName + &quot;该文件不存在，无法下载&quot;); return; &#125; response.setContentType(&quot;application/octet-stream&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;inline;filename=&quot; + new String(targetFile.getName().getBytes(&quot;gb2312&quot;), &quot;ISO-8859-1&quot;)); // 读取要下载的文件，保存到文件输入流 FileInputStream in = new FileInputStream(targetFile); // 创建输出流 OutputStream out = response.getOutputStream(); // 创建缓冲区 byte buffer[] = new byte[1024]; int len = 0; // 循环将输入流中的内容读取到缓冲区当中 while ((len = in.read(buffer)) &gt; 0) &#123; // 输出缓冲区的内容到浏览器，实现文件下载 out.write(buffer, 0, len); &#125; // 关闭文件输入流 in.close(); // 关闭输出流 out.close();&#125; 图片显示前端 123&lt;p&gt;商家图片&lt;/p&gt;&lt;img src=&quot;$&#123;pageContext.request.contextPath&#125;/shop/loadImage.do?type=shop&amp;shopLogoPath=1513499222-avatar.jpg&quot; height=&quot;200&quot; width=&quot;200&quot;&gt; ShopController.java 1234567891011121314151617181920212223242526272829303132333435@RequestMapping(&quot;/loadImage.do&quot;)public void loadImage(String shopLogoPath,String type,HttpServletResponse response)&#123; String shopImagePath = &quot;&quot;; if(&quot;goods&quot;.equals(type))&#123; shopImagePath = PropertiesUtil.getString(&quot;goods.image.path&quot;); &#125;else if(&quot;shop&quot;.equals(type))&#123; shopImagePath = PropertiesUtil.getString(&quot;shop.image.path&quot;); &#125; File file = new File(shopImagePath+&quot;/&quot;+shopLogoPath); if(!file.isFile() || !file.exists())&#123; logger.error(&quot;不是文件或者文件不存在&quot;); &#125; OutputStream outputStream = null; try &#123; outputStream = response.getOutputStream(); FileUtils.copyFile(file,outputStream); outputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(outputStream != null)&#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 额外对文件的操作对文件版本进行排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// 获取 fileType的客户端 从 client 文件夹中获取所有文件private List&lt;ClientFile&gt; queryClientFile(String fileType) &#123; List&lt;ClientFile&gt; list = new ArrayList&lt;ClientFile&gt;(); String path = &quot;&quot;; if (CLIENTTYPE.equals(fileType)) &#123; path = resourceDir; &#125; else &#123; path = resourceDir + &quot;module/&quot; + fileType + &quot;/&quot;; &#125; File folder = new File(path); if (!folder.exists()) &#123; folder.mkdirs(); &#125; // 获取当前文件夹下 所有文件 List&lt;File&gt; files = getcurrentDirAllFiles(fileType, folder); ClientFile clientFile = null; for (File file : files) &#123; clientFile = new ClientFile(); clientFile.setClientFileName(file.getName()); // 获取文件版本 1.2.3 clientFile.setClientFileVersion(getFileVersion(file.getName())); // 获取文件 上传时间 将long类型转为String类型 clientFile.setUploadTime(LongToDate(file.lastModified())); list.add(clientFile); &#125; return list;&#125;// 获取当前文件夹下 所有文件 按文件版本大小private List&lt;File&gt; getcurrentDirAllFiles(String fileType, File f) &#123; File fa[] = f.listFiles(); List&lt;File&gt; files = new ArrayList&lt;File&gt;(); if(fa != null &amp;&amp; fa.length &gt; 0) &#123; // 客户上传文件 存储dll文件 需要压缩完.rar或者.zip提交给后台 // 客户下载文件dll类型文件 服务器 .rar或者.zip后缀文件发送给客户 if (!fileType.equals(&quot;exe&quot;)) &#123; for (int i = 0; i &lt; fa.length; i++) &#123; File fs = fa[i]; if (!fs.isDirectory() &amp;&amp; (fs.getName().indexOf(&quot;.zip&quot;) &gt; -1)) &#123; files.add(fs); &#125; &#125; &#125; // 客户上传文件 存储exe文件 .exe后缀文件 提交给后台 // 客户下载文件exe类型文件 服务器 后缀文件发送给客户 if (fileType.equals(&quot;exe&quot;)) &#123; for (int i = 0; i &lt; fa.length; i++) &#123; File fs = fa[i]; if (!fs.isDirectory() &amp;&amp; fs.getName().indexOf(&quot;.exe&quot;) &gt; -1) &#123; files.add(fs); &#125; &#125; &#125; &#125; // 进行文件名排序 排序的内容比较为 1.2.3 小于 1.3.4 Collections.sort(files, new FileVersionComparator()); return files;&#125;// 截取文件版本 通过正则表达式截取成 -v1.2.3.exe 再截取为 1.2.3进行比较private String getFileVersion(String fileName) &#123; String version = &quot;&quot;; // 正则表示 只截取 开头为-v后缀为(.exe|.rar|.zip)// String pattern = &quot;-v.+(.exe|.rar|.zip)$&quot;; String pattern = &quot;-v.+(.exe|.zip)$&quot;; Pattern r = Pattern.compile(pattern); Matcher m = r.matcher(fileName); if (m.find()) &#123; version = m.group(); if (version.indexOf(&quot;.exe&quot;) &gt; -1) &#123; int index = version.indexOf(&quot;.exe&quot;); version = version.substring(2, index); &#125; if (version.indexOf(&quot;.zip&quot;) &gt; -1) &#123; int index = version.indexOf(&quot;.zip&quot;); version = version.substring(2, index); &#125; &#125; return version;&#125;public int versionStrToInt(String str) &#123; // 将文件名xxx-assistant-beta-v1.2.3.exe 切割成 1.2.3 str = getFileVersion(str); // 1.2.3 转换为 020230 // 2.3.12 转换为 020312 String[] tmpArr = str.split(&quot;\\.&quot;); int total = 0; try &#123; int length = tmpArr.length - 1; for (int i = 0; i &lt;= length; i++) &#123; int k = Integer.valueOf(tmpArr[i]); total += (int) (k * Math.pow(100, (length - i))); &#125; &#125; catch (Exception e) &#123; logger.error(&quot;文件版本转换出错&quot;); // e.printStackTrace(); &#125; return total;&#125;/** * * 文件版本进行比较 1.2.3 &lt; 2.3.10 */class FileVersionComparator implements Comparator&lt;File&gt; &#123; @Override public int compare(File file1, File file2) &#123; String o1 = file1.getName(); String o2 = file2.getName(); // o1为空返回1 o2为空返回-1 // 不为空 将版本转化为 整数 1.2.3 010203 进行比较 if (StringUtils.isNotNullAndBlank(o1) &amp;&amp; StringUtils.isNotNullAndBlank(o2)) &#123; int i1 = versionStrToInt(o1); int i2 = versionStrToInt(o2); if (i2 &gt; i1) &#123; return 1; &#125; else if (i2 &lt; i1) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; else if (StringUtils.isNotNullAndBlank(o1)) &#123; return 1; &#125; else if (StringUtils.isNotNullAndBlank(o2)) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125; 按照时间 返回文件12345678910111213141516// 按照时间 返回最新的客户端文件 /* * private File getNewestFile(String fileType, File f) &#123; long max = 0; int * result = -1; File fa[] = f.listFiles(); * * if (fileType.equals(&quot;dll&quot;)) &#123; for (int i = 0; i &lt; fa.length; i++) &#123; File fs = * fa[i]; if (!fs.isDirectory() &amp;&amp; (fs.getName().indexOf(&quot;.zip&quot;) &gt; -1 || * fs.getName().indexOf(&quot;.rar&quot;) &gt; -1)) &#123; if (max &lt; fs.lastModified()) &#123; max = * fs.lastModified(); result = i; &#125; &#125; &#125; &#125; if (fileType.equals(&quot;exe&quot;)) &#123; for (int * i = 0; i &lt; fa.length; i++) &#123; File fs = fa[i]; if (!fs.isDirectory() &amp;&amp; * fs.getName().indexOf(&quot;.exe&quot;) &gt; -1) &#123; if (max &lt; fs.lastModified()) &#123; max = * fs.lastModified(); result = i; &#125; &#125; &#125; &#125; * * return result == -1?null:fa[result]; &#125; */]]></content>
      <categories>
        <category>springMVC文件上传下载及图片显示</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口文档]]></title>
    <url>%2F2017%2F12%2F16%2F%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[摘要: 接口文档 接口文档注意12345678910111213141516AjaxResult 返回的数据&#123; &quot;statusCode&quot;: 200, &quot;message&quot;: &quot;操作成功&quot;, &quot;causeBy&quot;: null, &quot;callBackTypes&quot;: null, &quot;method&quot;: null, &quot;needTranslate&quot;: false, &quot;type&quot;: &quot;__custom&quot;, &quot;data&quot;: null, //如果需要data的时候可以在此处获取 &quot;translateBodys&quot;: null, &quot;callbackType&quot;: null&#125;所有属性中的 createTime 和 lastModifyTime 都由后台解决即可 用户登录 用户登录 异步Ajax url： /onlineShopping/login.do 参数：{&quot;userId&quot;:&quot;数据&quot;} response: ajaxResult 用户退出 异步Ajax url： /onlineShopping/logout.do 参数：{User:属性} //页面重定向(后续对应修改) 也可以改成异步方式 response: &quot;redirect:login.jsp&quot;; 获取当前已经登录的用户信息 异步Ajax url： /onlineShopping/getCurrentLoginUser.do 参数：{无} response: User对象的信息 用户user 通过userId获取user信息 异步Ajax url： /onlineShopping/user/loadUser.do 参数：{&quot;userId&quot;:&quot;数据&quot;} response: user对象 增user 异步Ajax url： /onlineShopping/user/addUser.do 参数：{User:属性} response: ajaxResult(data中存放用户信息) 删user 异步Ajax url： /onlineShopping/user/deleteUser.do 参数：{&quot;userId&quot;:&quot;数据&quot;} response: ajaxResult 改user 表单Form url： /onlineShopping/user/updateUser.do 参数：{User:属性} response: ajaxResult 校验userCode是否存在 异步Ajax url： /onlineShopping/user/checkUserCode.do 参数：{&quot;userCode&quot;:&quot;值&quot;} response: 整型(0:表示不存在) 商家shop 通过shopId获取shop信息 异步Ajax url： /onlineShopping/shop/loadShop.do 参数：{&quot;shopId&quot;:&quot;数据&quot;} response: shop对象 增shop 表单Form url： /onlineShopping/shop/addShop.do 参数：Shop的属性和图片 参数接收名 shopImage response: ajaxResult 注意：未传图片也默认添加失败 删shop 异步Ajax url： /onlineShopping/shop/deleteShop.do 参数：{&quot;shopId&quot;:&quot;数据&quot;} response: ajaxResult 改shop 表单Form url： /onlineShopping/shop/updateShop.do 参数：Shop的属性和图片 参数接收名 shopImage response: ajaxResult 注意：图片可以不传 默认使用之前的，如果上传图片代替以前的 获取所有的商家数据 进行分页 异步Ajax url： /onlineShopping/shop/queryShopPage.do 参数：{&quot;pageNum&quot;:数值,&quot;pageSize&quot;:数值} 参数说明：第几页,一页几个(前端不传，后台默认0,10) response: PageInfo&lt;Shop&gt; shop分页数据 加载图片 &lt;img src=&quot;url?参数&quot; url： /onlineShopping/shop/loadImage.do 参数：shopLogoPath=shop.shopLogoPath&amp;type=shop 注意：type就传2种值 goods/shop response: 图片的二进制数据 校验shopName是否存在 异步Ajax url： /onlineShopping/shop/checkShopName.do 参数：{&quot;shopName&quot;:&quot;值&quot;} response: 整型(0:表示不存在) 商品goods 通过goodsId获取goods信息 异步Ajax url： /onlineShopping/goods/loadGoods.do 参数：{&quot;goodsId&quot;:&quot;数据&quot;} response: goods对象 增goods 表单Form url： /onlineShopping/goods/addGoods.do 参数：goods的属性和图片 参数接收名 goodsImage response: ajaxResult 注意：未传图片也默认添加失败 删goods 异步Ajax url： /onlineShopping/goods/deleteGoods.do 参数：{&quot;goodsId&quot;:&quot;数据&quot;} response: ajaxResult 改goods 表单Form url： /onlineShopping/goods/updateGoods.do 参数：goods的属性和图片 参数接收名 goodsImage response: ajaxResult 注意：图片可以不传 默认使用之前的，如果上传图片代替以前的 获取当前商家对应商家的商品 进行分页 异步Ajax url： /onlineShopping/goods/getGoodsByUserId.do 参数：{&quot;pageNum&quot;:数值,&quot;pageSize&quot;:数值} 参数说明：第几页,一页几个(前端不传，后台默认0,10) response: PageInfo&lt;Goods&gt; 分页的数据(包含原需要展示的数据) 获取选中的商家展示对应的商品 进行分页 异步Ajax url： /onlineShopping/goods/getGoodsByShopId.do 参数：{&quot;pageNum&quot;:数值,&quot;pageSize&quot;:数值,&quot;shopId&quot;:&quot;值&quot;} 参数说明：第几页,一页几个(前端不传，后台默认0,10) response: PageInfo&lt;Goods&gt; 分页的数据(包含原需要展示的数据) 首页遍历商品 可选择类型 搜索 分页 异步Ajax url： /onlineShopping/goods/queryGoodsHomePage.do 参数：{&quot;pageNum&quot;:数值,&quot;pageSize&quot;:数值,&quot;goodsName&quot;:&quot;&quot;,&quot;goodsType&quot;:&quot;&quot;} 参数说明：第几页,一页几个(前端不传，后台默认0,10)，后面2个参数可不传 response: PageInfo&lt;Goods&gt; 分页的数据(包含原需要展示的数据) 订单order 通过orderId获取order信息 异步Ajax url： /onlineShopping/order/loadOrder.do 参数：{&quot;orderId&quot;:&quot;数据&quot;} response: ajaxResult 增order 异步Ajax url： /onlineShopping/order/addOrder.do 参数：{Order:属性} response: order对象 删order 异步Ajax url： /onlineShopping/order/deleteOrder.do 参数：{&quot;orderId&quot;:&quot;数据&quot;} response: ajaxResult 改order 异步Ajax url： /onlineShopping/order/updateOrder.do 参数：{Order:属性} response: ajaxResult 添加临时订单 异步Ajax url： /onlineShopping/order/addTempOrder.do 参数：{Order:属性} response: List&lt;Order&gt; 添加后order的数组 删除临时订单 异步Ajax url： /onlineShopping/order/deleteTempOrder.do 参数：{orderId:&quot;值&quot;} response: List&lt;Order&gt; 删除后order的数组 展示临时订单 异步Ajax url： /onlineShopping/order/getTempOrder.do 参数：{无} response: List&lt;Order&gt; order的数组 获取该用户的订单信息 进行分页 异步Ajax url： /onlineShopping/order/getOrderByUserId.do 参数：{&quot;pageNum&quot;:数值,&quot;pageSize&quot;:数值} 参数说明：第几页,一页几个(前端不传，后台默认0,10) response: PageInfo&lt;Order&gt; 分页的数据(包含原需要展示的数据) 当前用户确认订单买家商家都可以 异步Ajax url： /onlineShopping/order/confirmOrder.do 参数：{&quot;orderId&quot;:&quot;值&quot;} response: AjaxResult 当前用户取消订单买家商家都可以 异步Ajax url： /onlineShopping/order/cancelOrder.do 参数：{&quot;orderId&quot;:&quot;值&quot;} response: AjaxResult 反馈feedBack 通过feedBackId获取feedBack信息 异步Ajax url： /onlineShopping/feedBack/loadFeedBack.do 参数：{&quot;feedBackId&quot;:&quot;数据&quot;} response: feedBack对象 增feedBack 异步Ajax url： /onlineShopping/feedBack/addFeedBack.do 参数：{FeedBack:属性} response: ajaxResult 删feedBack 异步Ajax url： /onlineShopping/feedBack/deleteFeedBack.do 参数：{&quot;feedBackId&quot;:&quot;数据&quot;} response: ajaxResult 改feedBack 异步Ajax url： /onlineShopping/feedBack/updateFeedBack.do 参数：{FeedBack:属性} response: ajaxResult 判断 当前用户是否已经评论该商品 异步Ajax url： /onlineShopping/feedBack/checkUserIsFeedBack.do 参数：{&quot;goodsId&quot;:&quot;值&quot;} response: 整型 (评论过1 未评论为0) 商家 回复买家的评论 异步Ajax url： /onlineShopping/feedBack/revertFeedBack.do 参数：{&quot;feedBackId&quot;:&quot;反馈编码&quot;,&quot;shopRevert&quot;:&quot;商家回复信息&quot;} response: 整型 (评论过1 未评论为0)]]></content>
      <categories>
        <category>接口文档</category>
      </categories>
      <tags>
        <tag>接口文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题]]></title>
    <url>%2F2017%2F12%2F03%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[摘要: 跨域问题的解决方案 跨域问题2种解决方案 127.0.0.1 向 外网发送一个请求 前端会报错(Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is prese…) 第一种也是比较简单的就是从后台发送跨域请求1234567891011121314151617181920212223242526272829303132@RequestMapping(&quot;/load.do&quot;) @ResponseBody public String load(int id)&#123; String result = null; JobGroup jobGroup = jobGroupDao.load(id); if(jobGroup != null) &#123; List&lt;String&gt; registryList = null; if (jobGroup.getAddressType() == 0) &#123; registryList = JobRegistryMonitorHelper.discover(RegistryConfig.RegistType.EXECUTOR.name(), jobGroup.getAppName()); &#125; else &#123; if (StringUtils.isNotBlank(jobGroup.getAddressList())) &#123; registryList = Arrays.asList(jobGroup.getAddressList().split(&quot;,&quot;)); &#125; &#125; jobGroup.setRegistryList(registryList); &#125; try &#123; byte[] bytes = HttpClientUtil.postRequest(&quot;http://&quot;+jobGroup.getRegistryList().get(0)+&quot;/getAllHandlers.do&quot;, null); result = new String(bytes,&quot;UTF-8&quot;); //如果返回结果是 4com.bosssoft.xxx 说明访问失败 //或者 null 说明注册成功 但是无@Hander if(result.indexOf(&quot;4com&quot;) &gt; -1 || result.indexOf(&quot;null&quot;) &gt; -1) &#123; result = &quot;&quot;; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; 另外一种方式就在前端发送(jsonp)后续补上…]]></content>
      <categories>
        <category>跨域问题</category>
      </categories>
      <tags>
        <tag>跨域问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm引入tk-mybatis]]></title>
    <url>%2F2017%2F12%2F03%2Fssm%E5%BC%95%E5%85%A5tk-mybatis%2F</url>
    <content type="text"><![CDATA[摘要: ssm引入tk-mybatis tk-mybatis引入搭建好ssm项目pom.xml 123456789101112131415&lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;&lt;!-- tk.mybatis 对应的分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 通用的mybatisMapper类 --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt; applicationContext-dao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt; &lt;!-- 开启spring注解方式 --&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!-- 加载db.properties文件内容，文件的内容key需要特殊命名化 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;bean id=&quot;log-filter&quot; class=&quot;com.alibaba.druid.filter.logging.Log4jFilter&quot;&gt; &lt;property name=&quot;resultSetLogEnabled&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean name=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;jdbc.minIdle&#125;&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;jdbc.maxActive&#125;&quot; /&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;jdbc.maxWait&#125;&quot; /&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;&quot; /&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;jdbc.minEvictableIdleTimeMillis&#125;&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;$&#123;jdbc.validationQuery&#125;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;$&#123;jdbc.testWhileIdle&#125;&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;jdbc.testOnBorrow&#125;&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;$&#123;jdbc.testOnReturn&#125;&quot; /&gt; &lt;property name=&quot;removeAbandoned&quot; value=&quot;$&#123;jdbc.removeAbandoned&#125;&quot; /&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;$&#123;jdbc.removeAbandonedTimeout&#125;&quot; /&gt; &lt;!-- &lt;property name=&quot;logAbandoned&quot; value=&quot;$&#123;jdbc.logAbandoned&#125;&quot; /&gt; --&gt; &lt;property name=&quot;filters&quot; value=&quot;$&#123;jdbc.filters&#125;&quot; /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;proxyFilters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;log-filter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 监控数据库 --&gt; &lt;!-- &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; --&gt; &lt;!-- &lt;property name=&quot;filters&quot; value=&quot;mergeStat&quot; /&gt;--&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:mapper/*.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.ssm.pojo&quot;/&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 这里的几个配置主要演示如何使用，如果不理解，一定要去掉下面的配置 --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; &lt;!-- 分页插件使用哪种方言 --&gt; helperDialect=mysql &lt;!--reasonable=true--&gt; &lt;!--supportMethodsArguments=true--&gt; &lt;!--params=count=countSql--&gt; &lt;!-- 允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver） --&gt; autoRuntimeDialect=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- org.mybatis的方式 --&gt; &lt;!--&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash; 扫描包路径，如果需要扫描多个包的位置，需要用,分开半月逗号分隔开 &amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;basePackage&quot; value=&quot;com.ssm.mapper&quot;&gt;&lt;/property&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash; 注意这里是value 而不是ref &amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!-- tk.mybatis的方式 --&gt; &lt;bean class=&quot;tk.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.ssm.mapper&quot;/&gt; &lt;!-- 通用Mapper通过属性注入进行配置，默认不配置时会注册Mapper&lt;T&gt;接口 &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; mappers=tk.mybatis.mapper.common.Mapper &lt;/value&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; &lt;!-- mybatis 测试时使用 spring注入 --&gt; &lt;!--&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot; scope=&quot;prototype&quot;&gt;--&gt; &lt;!--&lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt;&lt;/beans&gt; 此时tk-mybatis已经整入项目中，再使用上分页插件pagehelper 使用例子： UserMapper.java 123public interface UserMapper extends Mapper&lt;User&gt;&#123;&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728293031@Service(&quot;userService&quot;)//@Transactional(rollbackFor=java.lang.Exception.class) service配置回滚 在配置文件中配置public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper;public Map&lt;String, Object&gt; queryUserPage(UserVo userVo) throws Exception &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); List&lt;User&gt; users = null; int total = 0; PageHelper.offsetPage(userVo.getStart(),userVo.getLength()); //使用该方式需要在User配置 //@Table(name = &quot;sys_user&quot;) //@Id Example example = new Example(User.class); example.createCriteria().andLike(&quot;username&quot;,userVo.getUsername()); users = userMapper.selectByExample(example); total = userMapper.selectCountByExample(example); map.put(&quot;recordsFiltered&quot;, total); map.put(&quot;data&quot;, users); map.put(&quot;recordsTotal&quot;, total); return map; &#125; &#125; 整合过程中出现的问题及解决方案 tk.mybatis.mapper.MapperException: java.lang.IllegalStateException: No typehandler found for property menus 报错的位置锁定在 UserMapper.xml 报错的原因是 12345678910111213141516171819202122232425262728293031User.java private String id; private String usercode; private String username; private String password; private String salt; private int locked; //用户菜单 private List&lt;SysPermission&gt; menus = new ArrayList&lt;SysPermission&gt;(); //用户权限 private List&lt;SysPermission&gt; permissions = new ArrayList&lt;SysPermission&gt;(); UserMapper.xml &lt;resultMap type=&quot;com.ssm.pojo.User&quot; id=&quot;userResultMap&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;usercode&quot; property=&quot;usercode&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;salt&quot; property=&quot;salt&quot;/&gt; &lt;result column=&quot;locked&quot; property=&quot;locked&quot;/&gt; &lt;/resultMap&gt; ``` menus 和 permissions的数据都不是从sys_user中获取的，但是UserMapper.xml中&lt;ResultMap&gt; 标签必须写上所有的映射 否则就会报以上的错误，但是配置上 &lt;result column=&quot;menus&quot; property=&quot;menus&quot;/&gt; 还是不行，No typehandler 最终的解决方案 public class SystemUser extends User implements Serializable { //用户菜单 private List&lt;SysPermission&gt; menus = new ArrayList&lt;SysPermission&gt;(); //用户权限 private List&lt;SysPermission&gt; permissions = new ArrayList&lt;SysPermission&gt;(); ```]]></content>
      <categories>
        <category>tk-mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web中间件]]></title>
    <url>%2F2017%2F11%2F29%2Fweb%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[摘要: web中间件 前言一般本地开发的话建议使用tomcat。linux系统建议使用jetty或apache hpptd大型的项目就用JBOSS或webloigc小项目，或者是个人开发tomcat 大项目或者商业项目一般采用：weblgoic/webshere其他的还有jboss、glasshfish等一些示例项目或者小项目常采用jettytomcat , jboss, weblogic, websphere 一般项目tomcat就可以了Tomcat是Sun的JSWDK(JavaServer Web Development Kit)中Servlet的运行环境(servlet容器)。Tomcat是Apache Jakarta软件组织的一个子项目，Tomcat是一个JSP/Servlet容器，它是在SUN公司的JSWDK（Java Server Web Development Kit）基础上发展起来的一个JSP和Servlet规范的标准实现，使用Tomcat可以体验JSP和Servlet的最新规范。经过多年的发展，Tomcat不仅是JSP和Servlet规范的标准实现，而且具备了很多商业Java Servlet容器的特性，并被一些企业用于商业用途。JBoss是一个运行EJB的J2EE应用服务器。它是开放源代码的项目，遵循最新的J2EE规范。从JBoss项目开始至今，它已经从一个EJB容器发展成为一个基于的J2EE的一个web 操作系统（operating system for web），它体现了J2EE规范中最新的技术WebLogic服务器是企业级的应用服务器，支持EJB, 集群以及 ERP（企业资源计划）的连通性 ，开发公司：BEA。WebSphere产品系列是IBM公司一套典型的电子商务应用开发工具及运行环境 tomcatweblogic]]></content>
      <categories>
        <category>web中间件</category>
      </categories>
      <tags>
        <tag>web中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ztree进阶学习记录]]></title>
    <url>%2F2017%2F11%2F03%2Fztree%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要: ztree进阶学习记录 ztree异步加载 由于ztree的数据量增大，通过直接将所有的ztree的节点都全部加载的方式，就会变得越来越慢的，所以为了解决这个问题。 解决的方案： 每次点击parent节点时才去加载此下的子节点挂于此节点下，点击树节点，table/grid回显示对应的数据，同时得注意： 此parent节点下异步加载的子节点需要判断是否是父节点，否则无法显示是否parent也就是无打开节点的按钮。 由于需要判断是否是父节点，所以需要后台传递值给前端带有isParent(true|false)。 如果没有isParent这个字段也会影响，zTreeObj.addNodes这个方法无法有效果。 同时为了实现增删改节点时，保持原本节点打开状态，而不是重新加载并且完全闭合。 12345678910111213141516171819202122在ztree处开启 isAsync=&quot;true&quot; 开启异步加载&lt;Tree id=&quot;functiontree&quot; layoutHeight=&quot;0&quot; width=&quot;100%&quot; hasRoot=&quot;true&quot; idField=&quot;treeId&quot; rootId=&quot;&quot; isAsync=&quot;true&quot;parentField=&quot;treeParentId&quot; nameField=&quot;treeText&quot; rootName=&quot;应用功能列表&quot; hasQry=&quot;true&quot; fit=&quot;true&quot;searchUrl=&quot;platform/appframe/function/afaappfunction/getAppFunctionTreeByName.do&quot; loadUrl=&quot;platform/appframe/function/afaappfunction/getAppFunctionTree.do&quot;/&gt;//设置树异步加载参数$A(&quot;#functiontree&quot;).setting.async.otherParam = &#123;&quot;isDisableType&quot;:&quot;NO&quot;&#125;; //设置异步加载时自动提交父节点属性的参数$A(&quot;#functiontree&quot;).setting.async.autoParam = [&quot;treeId&quot;]; 对应ztreeAPI： var setting = &#123; ..., async : &#123; autoParam:[], otherParam:[], url:&quot;&quot;, type:&quot;&quot;, dataType:&quot;text&quot; &#125; &#125; update前端提交修改保存完controller后，返回成功的信息，ajax的callback方法中对ztree中修改的节点信息修改 12345678910111213141516171819202122$a.messager.correct(&quot;操作成功&quot;);//当前选中的节点var currentObj = _self.copyObject;//获取ztree所有的节点var nodes = $A(&apos;#functiontree&apos;).getNodes();//获取提交表单的所有数据var data = $A(&quot;#afaappfunctionPage_forms_show&quot;).getSumbitData(); if (nodes.length&gt;0) &#123; currentObj.treeData.funcName = data.data.funcName; currentObj.treeText = currentObj.treeId+&quot; &quot;+currentObj.treeData.funcName; currentObj.treeData.funcType = data.data.funcType; currentObj.treeData.funcUrl = data.data.funcUrl; currentObj.treeData.isMenu = data.data.isMenu; currentObj.treeData.isAuthorize = data.data.isAuthorize; currentObj.treeData.isDisable = data.data.isDisable; currentObj.treeData.funcDesc = data.data.funcDesc; //将对应的ztree的节点进行更新 $A(&apos;#functiontree&apos;).updateNode(currentObj);&#125;``` add前端提交新增保存完controller后，返回对应的新增的节点(json)，ajax的callback方法中对前端的ztree新增显示节点 123456789101112131415161718192021222324252627var flag=false;//获取ztree选中的节点var selectedNode = AfaAppFunctionDlg.getInstance().treeObj.getSelectedNodes()[0];var selectedTreeCode = selectedNode.treeId;// 如果treeId 为空情况下使用treeData.appId 进行获取treeId进行识别if(selectedTreeCode==&quot;&quot;||selectedTreeCode==undefined||selectedTreeCode==null)&#123; selectedTreeCode = selectedNode.treeData.appId; flag=true;&#125;$A(&apos;#afaappfunctionPage_form&apos;).sumbitAllComp(&#123;...//获取ztree所有的节点var treeObj = AfaAppFunctionDlg.getInstance().treeObj;var parentNode = null;if(flag)&#123; //获取节点中有treeId为‘selectedTreeCode’的节点 parentNode = treeObj.getNodeByParam(&quot;treeId&quot;, selectedTreeCode, null);&#125;else&#123; //获取节点中有treeId为‘selectedTreeCode’的节点 parentNode = treeObj.getNodeByParam(&quot;treeId&quot;, selectedTreeCode, null);&#125;parentNode.isLeaf= &quot;0&quot;;parentNode.isParent=true;treeObj.updateNode(parentNode);treeObj.addNodes(parentNode, json); $a.messager.correct(&quot;操作成功&quot;); delete前端提交批量删除保存完controller后，返回操作成功提示，ajax的callback方法中对前端的ztree进行批量删除 1234567891011121314151617181920var treeObj = $A(&quot;#lefttree&quot;);var treeNode = treeObj.getSelectedNodes()[0];var parentNode = treeNode.getParentNode();//rowList 删除节点的数组 for(var attr in rowList)&#123; var menuId = rowList[attr][&quot;menuId&quot;] //获取存在 node.menu和node.treeData.menuId是&apos;menuId&apos;的树节点 var node = treeObj.getNodesByFilter(function(node)&#123;return (node.menu &amp;&amp; node.treeData.menuId == menuId)&#125;,true); //将该节点从树中移除 treeObj.removeNode(node);&#125; treeNode = treeObj.getSelectedNodes()[0]; if(treeNode)&#123; //需要对修改的树节点的父节点进行判断是否存在子节点 treeNode.isParent = treeNode.children.length == 0?false:true; treeObj.updateNode(treeNode);&#125;parentNode.isParent = parentNode.children.length == 0?false:true;treeObj.updateNode(parentNode); move树节点进行移动. 123456前端需要使用的到的代码//被移开的节点treeObj.removeNode(node);//被移动到的节点treeObj.updateNode(parentNode);treeObj.addNodes(parentNode, json);]]></content>
      <categories>
        <category>ztree</category>
      </categories>
      <tags>
        <tag>ztree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Web Module Cannot Transform]]></title>
    <url>%2F2017%2F11%2F02%2FDynamic%20Web%20Module%20Cannot%20Transform%2F</url>
    <content type="text"><![CDATA[摘要: Dynamic Web Module Cannot Transform 解决方案 web项目出现Dynamic Web Module 无法从2.3转化为2.5的版本。 解决方案： 首先出现问题的原因在于你的==web.xml==： 1234 &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee&quot;xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; 项目还是2.3的，而使用的version=2.5的，项目会报错（大致的意思就是无法转化），可以通过在本地项目中.setting文件中进行手动改变为2.5。（mac正常情况下是查看到.setting文件 可以通过 **shift+command+.**）]]></content>
      <categories>
        <category>Dynamic Web Module</category>
      </categories>
      <tags>
        <tag>Dynamic Web Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven常用命令]]></title>
    <url>%2F2017%2F11%2F02%2Fmaven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[摘要: maven常用命令 maven常用命令maven install 将项目根据pom.xml（packaging）的类型进行打包，同时清除项目中target之前打包。 场景1： web项目需要引用parent的项目[存在私服中]，欲将web项目应用引用 本地parent的项目[需要从私服下载到本地,然后执行下面的命令]。 把parent项目中所有的引用项目进行打包，便于本地进行修改测试 场景2： 引用的项目来自gitlab上，gitlab所引用的项目已经在gitlab上已经更新的，但是在maven repository中的还未改变。 解决方案：可以通过将gitlab上的项目下载下来，然后进行install 生成新的jar包或者其他的包。 12345其中用到的操作：git initgit clone gitLab地址cd 对应的项目（项目的上下文）中mvn clean install 生成最新的jar包或其他包 123456//相当于 maven clean install//不想用mvn clean又想保证jar包最新mvn install -Djar.forceCreationmaven clean install//maven的debugg信息非常完备，需要查看debug信息只要在命令后面添加 -X 参数即可mvn clean install -X maven package 将项目快速进行打包pom.xml（packaging）的类型进行打包,同时清除项目中target之前打包。 场景：将parent中的某个模块修改代码完，打包发给他人临时(为了临时测试使用) 12mvn clean packagemvn package -Djar.forceCreation //上面maven install提到过 mvn dependency:tree 使用mvn查看项目jar之间的依赖关系 123cd appframe mvn dependency:tree --&gt; tree.txttree.txt 文件在当前目录下 显示]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BS任务调度学习记录]]></title>
    <url>%2F2017%2F11%2F02%2FBS%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要: BS任务调度quartz学习记录]]></content>
      <categories>
        <category>quartz</category>
      </categories>
      <tags>
        <tag>任务调度quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spring-annotation]]></title>
    <url>%2F2017%2F10%2F29%2F%E4%BD%BF%E7%94%A8spring-annotation%2F</url>
    <content type="text"><![CDATA[摘要: 使用及扫描spring-annotation 自定义spring-annotation使用和扫描@Target注解：用于描述注解的使用范围，超出范围时编译失败。 取值类型（ElementType）： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域（成员变量） 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention：描述注解的生命周期，即注解的生效范围。 取值范围（RetentionPolicy）： 1.SOURCE：在源文件中生效，仅存在java文件中，class文件将会去除注解。 2.CLASS：在class文件中生效，仅保留在class文件中，运行时无法获取注解。 3.RUNTIME:在运行时生效，保留在class文件中且运行时可通过反射机制获取。 @Documented：用于指定javac生成API时显示该注解信息。 @Inherited：标明该注解可以由子类继承，及子类可以继承父类的注解。而默认情况下，子类是不继承父类注解的。 自定义spring-annotation JobHander.java 123456789101112131415161718import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//用于描述类、接口(包括注解类型) 或enum声明@Target(&#123;ElementType.TYPE&#125;)//在运行时生效，保留在class文件中且运行时可通过反射机制获取。@Retention(RetentionPolicy.RUNTIME)//标明该注解可以由子类继承，及子类可以继承父类的注解。而默认情况下，子类是不继承父类注解的。@Inheritedpublic @interface JobHander &#123; String name() default &quot;&quot;; String value() default &quot;&quot;; &#125; 自定义抽象类 JobHandler.java 12345678910111213import com.bosssoft.platform.job.core.biz.model.JobResult;public abstract class JobHandler &#123; /** * job handler * @param params * @return * @throws Exception */ public abstract JobResult&lt;String&gt; execute(String... params) throws Exception; &#125; MyDemoJobHandler.java 继承==JobHandler==并且使用==JobHander==注解 12345678910111213141516171819202122232425import java.util.concurrent.TimeUnit;import org.springframework.stereotype.Service;import com.bosssoft.platform.job.core.biz.model.JobResult;import com.bosssoft.platform.job.core.handler.JobHandler;import com.bosssoft.platform.job.core.handler.annotation.JobHander;import com.bosssoft.platform.job.core.log.JobLogger;@JobHander(name=&quot;我的测试执行器任务&quot;,value=&quot;myDemoJobHandler&quot;)@Servicepublic class MyDemoJobHandler extends JobHandler&#123; @Override public JobResult&lt;String&gt; execute(String... arg0) throws Exception &#123; JobLogger.log(&quot;myJob, test.&quot;); for (int i = 5; i &lt; 10; i++) &#123; JobLogger.log(&quot;beat at:&quot; + i); TimeUnit.SECONDS.sleep(2); &#125; return JobResult.SUCCESS; &#125;&#125; 通过spring的applicationContext方法getBeansWithAnnotation获取使用了JobHander注解的类(定义的name、value、class) 部分源码： 12345678910111213141516171819202122232425262728293031// Class&lt;? extends Annotation&gt; 表示为 annotationType 为 继承Annotation的类public Map&lt;String, Object&gt; getBeansWithAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123; Map&lt;String, Object&gt; results = new LinkedHashMap&lt;String, Object&gt;(); for (String beanName : getBeanDefinitionNames()) &#123; BeanDefinition beanDefinition = getBeanDefinition(beanName); if (!beanDefinition.isAbstract() &amp;&amp; findAnnotationOnBean(beanName, annotationType) != null) &#123; results.put(beanName, getBean(beanName)); &#125; &#125; for (String beanName : getSingletonNames()) &#123; if (!results.containsKey(beanName) &amp;&amp; findAnnotationOnBean(beanName, annotationType) != null) &#123; results.put(beanName, getBean(beanName)); &#125; &#125; return results; &#125; final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123; Objects.requireNonNull(annotationClass); //通过类得到对应的annotation注解 return (A) annotationData().annotations.get(annotationClass);&#125;public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 123456789101112131415161718192021222324252627282930313233public class QueryAllHandler implements ApplicationContextAware &#123; private static ApplicationContext applicationContext = null; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; // init job handler action Map&lt;String, Object&gt; serviceBeanMap = this.applicationContext.getBeansWithAnnotation(JobHander.class); System.out.println(&quot;&lt;--------------------start--------------------&gt;&quot;); if (serviceBeanMap!=null &amp;&amp; serviceBeanMap.size()&gt;0) &#123; for (Object serviceBean : serviceBeanMap.values()) &#123; if (serviceBean instanceof JobHandler)&#123; String value = serviceBean.getClass().getAnnotation(JobHander.class).value(); String name = serviceBean.getClass().getAnnotation(JobHander.class).name(); JobHandler handler = (JobHandler) serviceBean; System.out.println(handler); System.out.println(name); System.out.println(value); list.add(name); &#125; &#125; &#125; System.out.println(&quot;&lt;--------------------end--------------------&gt;&quot;); System.out.println(list.toArray().toString()); &#125;&#125; 最后需要注意的地方： spring需要扫描到才可以得到该类 &lt;context:component-scan base-package=&quot;com.ssm.spring.*&quot; /&gt; 实际开发需要考虑的问题 实现方式通过以上方式，但是在实际项目中，不可能使用一次application就实现一次 ==ApplicationContextAware==，所以在项目中已经有实现了ApplicationContextAware的 类(RuntimeApplicationContext.java)。 平台已经存在了一个RuntimeApplicationContext.java，其他项目小组使用平台时， 有可能习惯使用直接小组封装的实现ApplicationContextAware的类(xxxxxxApplicationContext.java)， 这时就需要实现考虑 可动态调用已实现ApplicationContextAware的工具类SpringContextUtil.java， 实现的方式就是通过在xxx.properties 配置已经实现的ApplicationContextAware类的完全路径， 然后通过反射机制使用动态调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import java.util.Map;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class RuntimeApplicationContext implements BeanDefinitionRegistryPostProcessor, ApplicationContextAware &#123; /** * logger */ private static Logger logger = LoggerFactory.getLogger(RuntimeApplicationContext.class); /** * 系统中的context对象 */ private static ApplicationContext context = null; /** * * 获取Spring上下文ApplicationContext对象 * * @return ApplicationContext对象 */ public static ApplicationContext getContext() &#123; if (context == null) &#123; logger.error(&quot;当前context为空,可能是Spring配置文件中没有配置加载本类[&#123;&#125;]!&quot;, RuntimeApplicationContext.class.getName()); throw new IllegalStateException(&quot;当前没有Spring的applicationContext注入,请确定是否有配置Spring,并在Spring中配置了本类的注入!&quot; + RuntimeApplicationContext.class); &#125; return context; &#125; /** * 取指定类型的Bean,如果不存在或存在多于1个,则抛出异常IllegalStateException. * * @param &lt;E&gt; E * @param type type * @return 指定类型的Bean */ @SuppressWarnings(&quot;unchecked&quot;) public static &lt;E&gt; E getBeanByType(Class&lt;? extends E&gt; type) &#123; try &#123; String[] beanNames = getContext().getBeanNamesForType(type); if (beanNames != null &amp;&amp; beanNames.length == 1) &#123; return (E) getContext().getBean(beanNames[0]); &#125; if (beanNames == null || beanNames.length == 0) &#123; throw new IllegalStateException(&quot;未找到指定类型的Bean定义.&quot;); &#125; throw new IllegalStateException(&quot;找到多个同类型的Bean定义.&quot;); &#125; catch (Exception e) &#123; logger.error(&quot;根据类型在Spring上下文查找对象出错:&quot; + type, e); throw new IllegalStateException(&quot;根据类型在Spring上下文查找对象出错:&quot; + type, e); &#125; &#125; /** * * 从Spring Context中获取指定的Bean * * @param &lt;E&gt; E * @param beanName bean的名称 * @return bean对象 */ @SuppressWarnings(&quot;unchecked&quot;) public static &lt;E&gt; E getBean(String beanName) &#123; try &#123; return (E) getContext().getBean(beanName); &#125; catch (Exception e) &#123; // logger.error(&quot;在Spring上下文查找对象出错:&quot; + beanName, th); throw new IllegalStateException(&quot;在Spring上下文查找对象出错:&quot; + beanName); &#125; &#125; public static Map&lt;String,Object&gt; getBeansWithAnnotation(Class annotationClass)&#123; return getContext().getBeansWithAnnotation(annotationClass); &#125; public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type) &#123; return getContext().getBeansOfType(type); &#125; /** * 从Spring Context中获取指定的Bean * * @param &lt;E&gt; E * @param clazz clazz * @return 指定的Bean */ public static &lt;E&gt; E getBean(Class&lt;E&gt; clazz) &#123; return getBeanByType(clazz); // return getBean(clazz.getName()); &#125; /** * * 是否有指定的Bean存在. * * @param beanName beanName * @return 是否有指定的Bean存在. */ public static boolean containBean(String beanName) &#123; return getContext().containsBean(beanName); &#125; /** * * 用于在被Spring加载时，由Spring注入ApplicationContext对象 * * @param context 被注入的context对象 * @throws BeansException */ public void setApplicationContext(ApplicationContext context) throws BeansException &#123; logger.debug(&quot;Prepare injection spring applicationcontext[&#123;&#125;]&quot;, context.toString()); if (RuntimeApplicationContext.context != null) &#123; logger.warn(&quot;注意,已经注入过Spring上下文[&#123;&#125;],请检查配置是否有问题导致重复注入!&quot;, RuntimeApplicationContext.context.toString()); &#125; RuntimeApplicationContext.context = context; &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; // TODO Auto-generated method stub &#125; @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; // TODO Auto-generated method stub &#125;&#125; SpringContextUtil.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SpringContextUtil &#123; private static Logger logger=LoggerFactory.getLogger(SpringContextUtil.class); private static final String KEY_SPRING_APPLICATION_CONTEXT_AWARE_CLASS=&quot;spring.applicationcontextaware.class&quot;; private static Class getSpringApplicationContextAwareClass()throws Exception&#123; String className= PropertiesUtil.getProperty(KEY_SPRING_APPLICATION_CONTEXT_AWARE_CLASS, &quot;com.xxxx.xxxx.runtime.spring.RuntimeApplicationContext&quot;); return ClassUtils.forName(className, Thread.currentThread().getContextClassLoader()); &#125; /** * 获取Spring Bean * @param beanName bean名称 * @return */ public static &lt;E&gt; E getBean(String beanName)&#123; try&#123; Class applicationContextAwareClass=getSpringApplicationContextAwareClass(); Object result=MethodUtils.invokeStaticMethod(applicationContextAwareClass,&quot;getBean&quot;, new Object[]&#123;beanName&#125;); return (E)result; &#125;catch(Exception e)&#123; logger.error(&quot;Error get spring applicationContext bean &#123;&#125;&quot;,beanName,e); throw new RuntimeException(e); &#125; &#125; public static &lt;E&gt; E getBeanByType(Class&lt;? extends E&gt; type) &#123; try&#123; Class applicationContextAwareClass=getSpringApplicationContextAwareClass(); Object result=MethodUtils.invokeStaticMethod(applicationContextAwareClass,&quot;getBeanByType&quot;, new Object[]&#123;type&#125;); return (E)result; &#125;catch(Exception e)&#123; logger.error(&quot;Error get spring applicationContext bean of type &#123;&#125;&quot;,type.getClass(),e); throw new RuntimeException(e); &#125; &#125; public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; type)&#123; try&#123; Class applicationContextAwareClass=getSpringApplicationContextAwareClass(); Object result=MethodUtils.invokeStaticMethod(applicationContextAwareClass,&quot;getBeansOfType&quot;, new Object[]&#123;type&#125;); return (Map&lt;String, T&gt;)result; &#125;catch(Exception e)&#123; logger.error(&quot;Error get spring applicationContext bean of type &#123;&#125;&quot;,type.getClass(),e); throw new RuntimeException(e); &#125; &#125; /** * 根据注解获取Bean * @param type * @return */ public static Map&lt;String,Object&gt; getBeansWithAnnotation(Class type)&#123; try&#123; Class applicationContextAwareClass=getSpringApplicationContextAwareClass(); Object result=MethodUtils.invokeStaticMethod(applicationContextAwareClass,&quot;getBeansWithAnnotation&quot;, new Object[]&#123;type&#125;); return (Map&lt;String, Object&gt;)result; &#125;catch(Exception e)&#123; logger.error(&quot;Error get spring applicationContext bean with annotation &#123;&#125;&quot;,type.getClass(),e); throw new RuntimeException(e); &#125; &#125;&#125;]]></content>
      <categories>
        <category>spring-annotation</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro学习记录]]></title>
    <url>%2F2017%2F10%2F29%2Fshiro%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要: ssm+shiro+ehcache 遇到的问题问题一(NoClassDefFoundError) caused by: java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException 解决方案 缺少aspectjweaver.jar 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.1&lt;/version&gt;&lt;/dependency&gt; 问题二(java包下无法更新编译.xml文件) IDEA src下的目录除了==.java==其他文件无法==更新编译加载== 解决方案 在pom.xml文件中配置 12345678910111213141516171819202122232425262728293031323334&lt;build&gt; &lt;finalName&gt;demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- resources 编译执行包含以下类型文件 --&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.ini&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!-- java 编译执行包含以下类型文件 --&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 问题三(shiro一直处于登录页面,无法跳转到succeeURL) shiro一直处于登录页面,无法跳转到succeeURL,错误情况下可以进入到FormAuthenticationFilter 该文件中，但是正确情况下就无法进入，controller也接受不到错误信息。 提交Form表单给 (“/login”) methond必须是==POST== 不可以使用==GET==，否则就会出现上面的情况,可以查看下源码看到该情况。 shiro使用到 WebUtils 工具保存session 问题四(shiro实现了AuthorizingRealm，认证成功，无法授权) 错误的理解 拦截和授权为一回事。拦截是判断是是否登陆 授权是判断你是否有权限操作。在 filterChainDefinitions 配置(==/** = authc== 作用：所有url都必须认证通过才可以访问) 想要配置授权拦截应该配置(==/user/userList.do = perms[“user:query”]==) 或者使用注解 ==@RequiresPermissions(“user:query”)== applicationContext-shiro.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt; &lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.do&quot; /&gt; &lt;!-- 认证成功统一跳转到first.action，建议不配置，shiro认证成功自动到上一个请求路径 --&gt; &lt;!--&lt;property name=&quot;successUrl&quot; value=&quot;/main.do&quot;/&gt;--&gt; &lt;!-- 通过unauthorizedUrl指定没有权限操作时跳转页面--&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/refuse.jsp&quot; /&gt; &lt;!-- 自定义filter配置 --&gt; &lt;property name=&quot;filters&quot;&gt; &lt;map&gt; &lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中--&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 指定URL拦截规则 --&gt; &lt;!-- 过虑器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;!--authc:代表shiro框架提供的一个过滤器，这个过滤器用于判断当前用户是否已经完成认证， 如果当前用户已经认证，就放行，如果当前用户没有认证，跳转到登录页面 anon:代表shiro框架提供的一个过滤器，允许匿名访问--&gt; &lt;value&gt; &lt;!-- 对静态资源设置匿名访问 --&gt; /resouces/images/** = anon /resouces/js/** = anon /resouces/css/** = anon /resouces/bootstrap3/** = anon &lt;!-- 验证码，可匿名访问 --&gt; /authCode.do = anon &lt;!-- 请求 logout.action地址，shiro去清除session--&gt; /logout.do = logout &lt;!--商品查询需要商品查询权限 ，取消url拦截配置，使用注解授权方式 --&gt; &lt;!-- /items/queryItems.action = perms[item:query] /items/editItems.action = perms[item:edit] --&gt; &lt;!-- 配置记住我或认证通过可以访问的地址 --&gt; &lt;!--/main.do = user--&gt; /welcome.jsp = user &lt;!-- 使用配置方式实现授权操作 --&gt; &lt;!--/user/userList.do = perms[&quot;user:query&quot;]--&gt; &lt;!-- /** = authc 所有url都必须认证通过才可以访问--&gt; /** = authc &lt;!-- /** = anon所有url都可以匿名访问 --&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; UserController.java 12345678910@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @RequiresPermissions(&quot;user:query&quot;) @RequestMapping(&quot;/userList&quot;)]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2017%2F10%2F29%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[摘要: Linux常用命令 1234567891011121314151617181920//查看java进程 不存在则表示未启动ps -ef | grep javaps -ef | grep redisps -ef | grep zookeeperps -ef | grep weblogic//杀死对应需要的线程kill -9 weblogic的pid//启动weblogic切换界面不关闭，不中断开启nohup ./startWebLogic.sh &gt;test101802.log 2&gt;&amp;1//查看对应的logtail -f test101802.log//查找 xxx.lok的文件find . -name &quot;*.lok&quot;# find . -a */.lok find: 路径必须在表达式之前: */.lok 用法: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService到今天流行的RESTful API(JSON) over HTTP]]></title>
    <url>%2F2017%2F10%2F29%2FWebService%E5%88%B0RESTful%20API(JSON)%20over%20HTTP%2F</url>
    <content type="text"><![CDATA[摘要: WebService到今天流行的RESTful API(JSON) over HTTP WebService有很多协议，为什么HTTP比较流行？WebService是个很重型的规范，它的应用协议是SOAP（简单对象访问协议），它所依赖的下层通信方式不单单是HTTP，也有SOAP over SMTP, SOAP over TCP，由于HTTP协议群众基础广，开发调试方便，所以，成了WebService中最为流行的方式。 甚至很多公司在内网通信，也用HTTP来做，比如，应用调用搜索引擎，Solr就是一个例子。 但HTTP也是TCP上性能比较差的协议，因为HTTP是基于TCP的，有3次握手，再加上HTTP是个文本传输协议（虽然也可以传二进制的附件，但业务逻辑还是文本用的多），又有很多复杂的HEADER。所以人们发明了一些更高效的通信协议来做远程调用，比如ACE、ICE、Corba、淘宝的HSF，但这是后话了，不展开细说。你只要知道，HTTP之所以流行，乃是简单易用群众基础广的结果。 WebService为什么不如RESTful API流行WebService诞生十几年了，最初是IBM、微软比较热心在推，一直也不温不火。倒是XML-RPC, RESTful以及比RESTful还要简陋的远程调用方式后来居上。感觉是不是有点像民间的Spring干掉官方的EJB？ 究其原因，还是WebService实在太笨重了，SOAP信封犹如婆娘的裹脚布，又臭又长，广大开发人员是叔可忍嫂不能忍，于是就有了简化版的，叫XML-RPC，后来伴随着Web2.0流行，RESTful独领风骚。我在10年前做过一个产品，纯PHP+JS，标准的WebService，连WSDL我都要专门写个PHP程序来生成，还好只是我一个人开发，要是团队协作，我早就被骂得不成人形了。 再后来，连RESTful都被嫌弃了，大伙儿干脆连PUT、DELETE都懒得用，直接用GET和POST。 同时，我得说，这只是在互联网领域，大部分企业的业务逻辑相对简单，同时工期又变态的短（就像大部分互联网创业公司用糙快猛的PHP，而不用相对严谨的Java一样）。在某些业务复杂，稳定性和正确性要求高的领域（如ERP、电商、支付），WebService还有是用武之地的。 为什么JSON比XML流行还是易用性，JSON的可读性比XML强几条长安街，解析规则也简单许多。XML解析的时候规则太多了，动不动就非法字符，动不动就抛异常。这对追求高开发速度和低开发门槛的企业来说，是个致命伤。 JSON的缺点是数据类型支持较少，且不精确。比方说： 1price:12580 在json里，你无法知道这个价格是int, float还是double。 所以，如上面第二条所述，在一些业务要求较高的领域，还是XML更合适。 最后说一下性能，JSON的性能高于XML，除此之外，基于XML和HTTP的WebService, 基于JSON的RESTful API，并没有性能差异。 XML性能糟糕到什么地步呢，有一种专门的CPU叫做XML Accelerator，专门为XML解析提供硬件加速。]]></content>
      <categories>
        <category>WebService与RESTful</category>
      </categories>
      <tags>
        <tag>WebService与RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript开发学习记录]]></title>
    <url>%2F2017%2F10%2F14%2FJavascript%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要: Javascript开发学习记录 找个时间整理]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BS前端页面汇总]]></title>
    <url>%2F2017%2F09%2F28%2FBS%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[摘要: BS前端页面汇总 前端部分（XML、JS）前端使用到GS的框架： xml标签：Page、items、Panel、Tree、XGrid…JS使用到的是requireJS：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//define([&apos;引入外部js模块或控件&apos;],function(&apos;引入外部js或控件的别名&apos;)&#123;&#125;)define([&quot;app/widgets/window/app-dialog&quot;,&quot;目录&quot;,&quot;目录&quot;],function(Dialog,PageBase,dlg)&#123; var xxxModel = PageBase.extend(&#123; //类初始化 initialize : function()&#123; xxxModel.superclass.initialize.call(this); &#125;, //控件监听事件 格式：#控件id#:&#123;事件名:事件方法&#125; listeners:&#123; &#125;, //页面初始化 initPage:function()&#123; &#125;, //显示查看业 showViewPage:function(data,e)&#123; var _self=this; dlg.showPage(dlg.ACTION.VIEW,data,function()&#123; _self.refreshData(); &#125;); &#125;, refreshData:function()&#123; $(&quot;#receiptMaintenancePage_grid&quot;).grid(&quot;reload&quot;); &#125;, //显示编辑业 showEditPage:function(data,e)&#123; var _self=this; dlg.showPage(dlg.ACTION.EDIT,data,function()&#123; //_self.refreshData(); $(&quot;#receiptMaintenancePage_grid&quot;).grid(&quot;reload&quot;); &#125;); &#125;, //控件属性重置 initUIExtConfig : function() &#123; var _self=this; this.uiExtConfig=&#123; //格式 #控件id#:function(控件属性集类)&#123; config.setAttr(&quot;控件属性名&quot;,&quot;属性值&quot;),// 网格，下拉网格，特殊设置config.getColumn(&quot;网列id&quot;).setAttr(&quot;列属性名&quot;,&quot;列属性值&quot;)config.getButton(&quot;网格内包含的按钮id&quot;).setAttr(&quot;handler&quot;,&quot;点击事件&quot;) &#125; receiptMaintenancePage_grid:function(config)&#123; config.getButton(&quot;receiptMaintenancePage_grid_btnEdit&quot;).setAttr(&quot;handler&quot;,_self.showEditPage); config.getButton(&quot;receiptMaintenancePage_grid_btnView&quot;).setAttr(&quot;handler&quot;,_self.showViewPage); config.getButton(&quot;receiptMaintenancePage_grid_btnDel&quot;).setAttr(&quot;handler&quot;,_self.doDeleteData); &#125; &#125; &#125; &#125;); xxxModel.getInstance=function()&#123; if (!this.instance)&#123; this.instance =new xxxModel(); &#125; return this.instance; &#125; return xxxModel.getInstance();&#125;); XML经常使用到的方式树123456&lt;Tree id=&quot;receiptLeftTree&quot; layoutHeight=&quot;0&quot; width=&quot;100%&quot; hasRoot=&quot;true&quot; rootId=&quot;&quot; rootName=&quot;机构列表&quot; idField=&quot;treeId&quot; isAsync=&quot;true&quot; nameField=&quot;treeText&quot; parentField=&quot;treeParentId&quot; hasQry=&quot;true&quot; searchUrl=&quot;platform/appframe/afauser/searcherAfaUserTree.do&quot; searchFields=&quot;orgName&quot; loadUrl=&quot;platform/appframe/afauser/queryAfaUserTree.do&quot;&gt;&lt;/Tree&gt; 查询功能12345678910111213141516171819&lt;Query id=&quot;receiptMaintenancePage_query&quot; queryTarget=&quot;receiptMaintenancePage_grid&quot; isAdvance=&quot;true&quot; style=&quot;display:none;&quot; manual=&quot;false&quot; advColCount=&quot;2&quot;&gt; &lt;quicks&gt; &lt;QueryItem id=&quot;ticketedPointCode&quot; name=&quot;开票点&quot; tips=&quot;输入开票点编码查询&quot; field=&quot;TICKETED_POINT_CODE&quot; operator=&quot;like&quot; editorType=&quot;TEXTBOX&quot; /&gt; &lt;QueryItem id=&quot;startTime&quot; name=&quot;编制日期&quot; field=&quot;CREATE_TIME&quot; tips=&quot;输入编制日期查询&quot; operator=&quot;&gt;=&quot; editorType=&quot;DATETIME&quot; /&gt; &lt;QueryItem id=&quot;endTime&quot; name=&quot;至&quot; field=&quot;CREATE_TIME&quot; tips=&quot;输入编制日期查询&quot; operator=&quot;&amp;lt;=&quot; editorType=&quot;DATETIME&quot; /&gt; &lt;QueryItem id=&quot;gaoji&quot; name=&quot;高级&quot; value=&quot;1&quot; visible=&quot;false&quot; operator=&quot;=&quot; editorType=&quot;TEXTBOX&quot; /&gt; &lt;/quicks&gt; //高级查询 &lt;advances&gt; &lt;QueryItem id=&quot;ticketedPointCode&quot; name=&quot;开票点编码&quot; editorType=&quot;TEXTBOX&quot; /&gt; &lt;QueryItem id=&quot;createTime&quot; name=&quot;创建日期&quot; editorType=&quot;DATETIME&quot; /&gt; &lt;/advances&gt;&lt;/Query&gt; 标签页123456789101112131415161718192021&lt;Panel id=&quot;id必填&quot; region=&quot;定义布局面板的位置&quot;&gt; &lt;items&gt; &lt;Tabs id=&quot;receiptMaintenance_panel_right_bottom_tabs&quot;&gt; &lt;items&gt; &lt;TabPanel id=&quot;panel_south_tabs_projects_info&quot; name=&quot;项目&quot; layout=&quot;border&quot; style=&quot;height: 240px;&quot;&gt; &lt;items&gt; 内容可以是 XGrid或者Form &lt;/items&gt; &lt;/TabPanel&gt; &lt;TabPanel id=&quot;panel_south_tabs_user_info&quot; name=&quot;项目&quot; layout=&quot;border&quot; style=&quot;height: 240px;&quot;&gt; &lt;items&gt; 内容可以是 XGrid或者Form &lt;/items&gt; &lt;/TabPanel&gt; &lt;/items&gt; &lt;/Tabs&gt; &lt;/items&gt;&lt;/Panel&gt; XGridColumn实现下拉并且将row自动填写( XML 和 JS(在listeners中) )**1. XML: 12345678&lt;XGridColumn field=&quot;projectStandard&quot; title=&quot;项目标准&quot; editorType=&quot;COMBOBOX&quot; align=&quot;center&quot; editorOptions=&quot;&#123; textfield: &apos;projectStandard&apos;, valuefield: &apos;projectCode&apos;, url: &apos;platform/appframe/receipt/maintenance/receiptmaintenance/queryProjectList.do&apos; &#125;&quot; /&gt; 2. JS: 12345678910111213141516171819projects_grid_editable : &#123; onClickCell : function(rowData, rowIndex, field) &#123; var self = ReceiptMaintenanceDlg.getInstance(); if(field == &quot;projectStandard&quot;)&#123; var edProjectStandard = $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, field); var edProjectCode = $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, &quot;projectCode&quot;); $(edProjectStandard).combobox(&apos;reload&apos;,&apos;platform/appframe/receipt/maintenance/receiptmaintenance/queryProjectList.do?whichData=project&apos;); $(edProjectStandard).bind(&apos;change&apos;,function()&#123; var projectId = $(edProjectStandard).combobox(&quot;getValue&quot;); var projectStandard= $(edProjectStandard).combobox(&quot;getText&quot;); var rowIndex = $(&apos;#projects_grid_editable&apos;).grid(&apos;getCurrentEditRowIndex&apos;); var rowData = $(&apos;#projects_grid_editable&apos;).grid(&apos;getCurrentEditRowData&apos;); $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, &quot;projectCode&quot;).textbox(&apos;setValue&apos;,projectId); $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, &quot;projectCode&quot;).textbox(&apos;disable&apos;);// $(&apos;#projects_grid_editable&apos;).grid(&apos;saveRow&apos;, &#123;rowIndex : rowIndex, rowData:&#123;&apos;projectCode&apos;:projectId&#125;, command:&apos;update&apos;&#125;); &#125;); &#125; &#125;&#125; 将主表的数据和副表的数据一起发送给后台(增删改)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556doSave : function(config, callback) &#123; var gridData = $(&quot;#projects_grid_editable&quot;).grid(&apos;getAllData&apos;); var params = $A(&apos;#receiptMaintenancePage_form&apos;).getSumbitData(); var obj = new Object(); obj.gridData = gridData; obj.mainData = params.data; obj.type = &quot;modify&quot;; var myURL = &quot;platform/appframe/receipt/maintenance/receiptmaintenance/doInsertProject.do&quot;; $app.ajax.ajaxCall(&#123; url : myURL, data : obj, contentType:&apos;application/json&apos;, dataType: &apos;json&apos;, type: &apos;POST&apos;, callback : function(json) &#123; if (config.isSaveAdd) &#123; $A(&quot;#receiptMaintenancePage_form&quot;) .clearFormEditorValue(); _self.indexAction = _self.ACTION.ADD; &#125; else if (config.isSaveClose) &#123; $.closeDialog(); _self.indexAction = &quot;&quot;; &#125; else if (config.isSaveView) &#123; $A(&quot;#receiptMaintenancePage_form&quot;) .toggleFormState(&quot;view&quot;); $A(&quot;#id&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#ticketedPointCode&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#ticketedPointName&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#ticketedPointType&quot;).combobox(&quot;readonly&quot;, true); $A(&quot;#simpleCode&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#dataAcquisitionCycle&quot;).textbox(&quot;readonly&quot;, true);// $A(&quot;#createTime&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#sysAppMode&quot;).combobox(&quot;readonly&quot;, true); $A(&quot;#contacts&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#contactsInfo&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#superOrg&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#isOnline&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#remark&quot;).textbox(&quot;readonly&quot;, true); // $A(&quot;#sysAppMode&quot;).combobox(&quot;readonly&quot;, true); // $A(&quot;#sysAppModeRadioBox&quot;).radiobox(&quot;readonly&quot;, false);// $A(&quot;#emergencyTicketed&quot;).radiobox(&quot;readonly&quot;, false);// $A(&quot;#emergencyDays&quot;).textbox(&quot;readonly&quot;, false); _self.indexAction = _self.ACTION.VIEW; &#125; if (_self.showPageCallBack) &#123; _self.showPageCallBack(); &#125; &#125; &#125;);&#125; 从表的操作1234567891011121314151617181920initUIExtConfig : function() &#123; var _self = this; this.uiExtConfig = &#123; // 格式 #控件id#:function(控件属性集类)&#123; config.setAttr(&quot;控件属性名&quot;,&quot;属性值&quot;),// // 网格，下拉网格，特殊设置config.getColumn(&quot;网列id&quot;).setAttr(&quot;列属性名&quot;,&quot;列属性值&quot;)config.getButton(&quot;网格内包含的按钮id&quot;).setAttr(&quot;handler&quot;,&quot;点击事件&quot;) // &#125; projects_grid_editable:function(config)&#123; config.getButton(&quot;projects_grid_addBtn&quot;).setAttr(&quot;handler&quot;, _self.appendPGridRow); config.getButton(&quot;projects_grid_deleteBtn&quot;).setAttr(&quot;handler&quot;, _self.deletePGridRow); &#125;, receipts_grid_editable:function(config)&#123; config.getButton(&quot;receipts_grid_addBtn&quot;).setAttr(&quot;handler&quot;, _self.appendRGridRow); config.getButton(&quot;receipts_grid_deleteBtn&quot;).setAttr(&quot;handler&quot;, _self.deleteRGridRow); &#125;, users_grid_editable:function(config)&#123; config.getButton(&quot;users_grid_addBtn&quot;).setAttr(&quot;handler&quot;, _self.appendUGridRow); config.getButton(&quot;users_grid_deleteBtn&quot;).setAttr(&quot;handler&quot;, _self.deleteUGridRow); &#125; &#125;&#125; 前后台请求其中BS使用到的ajax自带的方式123456789101112131415161718192021222324252627前端JS：$app.ajax.ajaxCall(&#123; url : url, data : jsonData, callback : function(data) &#123; $(&quot;#receiptMaintenancePage_grid&quot;).grid(&quot;reload&quot;); &#125;&#125;);后台controller:public AajaxResult queryProect(@requestBody 对象 对象名)&#123;&#125;需要注意的是：Json格式：&#123; mainData:&#123;id:&apos;&apos;,name:&apos;&apos;&#125;, gridData:[&#123;gId:&apos;&apos;,gName:&apos;&apos;&#125;,&#123;gId:&apos;&apos;,gName:&apos;&apos;&#125;]&#125;pojo数据：public class myJsonRequest&#123; private Object mainData; private List&lt;Object&gt; gridData;&#125;才可以接受到 页面汇总echarts可视化图表 可以在bossjs中看到对应demo – js下拉框二级关联菜单js下拉框二级关联菜单效果代码具体实现(点击执行器得某一个，对应任务中的data会自动进行加载该执行器中的任务) 123456页面：&lt;QueryItem id=&quot;jobGroup&quot; name=&quot;执行器：&quot; editorType=&quot;COMBOBOX&quot; action=&quot;platform/appframe/jobcenter/joblog/jobGroupCBB.do&quot; comboFieldText=&quot;title&quot; comboFieldValue=&quot;val&quot; /&gt;&lt;QueryItem id=&quot;jobId&quot; name=&quot;任务：&quot; editorType=&quot;COMBOBOX&quot; data=&quot;[&#123;jobDesc:&apos;全部&apos;,id:&apos;0&apos;&#125;]&quot; comboFieldText=&quot;jobDesc&quot; comboFieldValue=&quot;id&quot; /&gt; 1234567891011121314151617181920212223242526272829303132js:(listener:&#123;&#125;)jobGroup : &#123; afterSelected : function(node)&#123; if(node.val == 0)&#123; $(&apos;#jobId&apos;).combobox(&apos;clearValue&apos;); $(&apos;#jobId&apos;).combobox(&apos;loadData&apos;, [&#123;jobDesc:&apos;全部&apos;,id:&apos;0&apos;&#125;]); &#125;else&#123; $(&apos;#jobId&apos;).combobox(&apos;clearValue&apos;); $(&apos;#jobId&apos;).combobox(&apos;reload&apos;,&apos;platform/appframe/jobcenter/joblog/getJobsByGroup.do?jobGroup=&apos;+node.val); &#125; &#125;&#125;获取数据：jobInfoPage_btnClear : &#123; click : function() &#123; var obj = &#123;&#125;; var jobNode = $(&apos;#jobId&apos;).data().selectNode; obj.jobNode = jobNode; var jobGroupNode = $(&apos;#jobGroup&apos;).data().selectNode; obj.jobGroupNode = jobGroupNode; if(jobNode == null || jobGroupNode == null)&#123; alert(&quot;请选择执行器和任务&quot;); return; &#125; dlg.showPage(dlg.ACTION.ADD, obj, function() &#123; JobLogModel.getInstance().refreshData(); &#125;) &#125;&#125;, – 时间区间选择(可选择时间段) 时间区间获取可以选择(昨天，上个月，去年。。。) 1234567&lt;QueryItem id=&quot;dateBegin&quot; name=&quot;开始时间：&quot; editorType=&quot;DATETIME&quot; width=&quot;210px&quot; editOptions=&quot;&#123; type: &apos;datetime&apos;, format:&apos;yyyy-mm-dd HH:ii:ss&apos;, dateend:&apos;dateEnd&apos; &#125;&quot;/&gt;&lt;QueryItem id=&quot;dateEnd&quot; name=&quot;结束时间：&quot; editorType=&quot;DATETIME&quot; width=&quot;210px&quot; editOptions=&quot;&#123; type: &apos;datetime&apos;,format:&apos;yyyy-mm-dd HH:ii:ss&apos; &#125;&quot;/&gt; – add/updat页面再弹窗并回填 在新增页面点击选择 -&gt; 跳转到 cron的页面选择时间（需要考虑的问题：点击选择时候，需要将新增页面的内容回填，同时带上cron的结果） 12345678910111213141516171819202122232425262728293031323334353637383940414243 选择按钮 在xxx_add.jsp中实现： &lt;af:page id=&quot;jobInfoPage&quot;&gt; &lt;button id=&quot;cronBtn&quot; style=&quot; position: absolute;right: 48px;top: 24px;cursor: pointer; background-color: #00c0ef;border-color: #00acd6; border-radius: 3px;color: #fff;box-shadow: none; width: 60px;height: 32px;border: 1px solid transparent; -webkit-box-shadow: none; touch-action: manipulation; &quot; &gt;选择&lt;/button&gt; &lt;/af:page&gt; //cron时间选择cronBtn : &#123; click : function() &#123; var self = JobInfoDlg.getInstance(); var d = &#123;&#125;; var data = $A(&apos;#jobInfoPage_form&apos;).serializeArray(); //将数组转换为对象 $.each(data, function() &#123; d[this.name] = this.value; &#125;); d[&apos;action&apos;] = self.indexAction; $.closeDialog(); // RequireJS 所以需要把该add的对象传递，用于回填add界面 jic.showPage(self,d, function(responseData) &#123; $A(&apos;#jobInfoPage_form&apos;).refreshFormData(responseData); &#125;); &#125;&#125;在xxx_add.js: showPage:function(.... 需要判断回填的data 不为空就回填数据，避免第一次add的data为空的带来的问题 if(data != &apos;&apos; &amp;&amp; data != &apos;undefined&apos; &amp;&amp; data != null)&#123; $A(&apos;#jobInfoPage_form&apos;).refreshFormData(data); &#125; Grid Column数据格式化 grid Column数据格式化 12345678config.getColumn(&quot;triggerCode&quot;).setAttr( &quot;formatter&quot;, function(val, row, i) &#123; if (val == 200) &#123; return &quot;&lt;span style=&apos;color:green;&apos;&gt;成功&lt;span/&gt;&quot;; &#125; else if (val == 500) &#123; return &quot;&lt;span style=&apos;color:red;&apos;&gt;失败&lt;span/&gt;&quot;; &#125; &#125;); – 页面combobox初始化 12345678910111213141516// 页面加载后初始化initPage : function() &#123; var title = $A(&apos;#jobGroup&apos;).combobox(&apos;getText&apos;); var val = $A(&apos;#jobGroup&apos;).combobox(&apos;getValue&apos;); var jobDesc = $A(&apos;#jobId&apos;).combobox(&apos;getText&apos;); var id = $A(&apos;#jobId&apos;).combobox(&apos;getValue&apos;); if(val == &apos;&apos; || val == undefined || title == &apos;&apos; || title == undefined)&#123; $A(&apos;#jobGroup&apos;).combobox(&apos;setValue&apos;,&apos;0&apos;); $A(&apos;#jobGroup&apos;).combobox(&apos;setText&apos;,&apos;全部&apos;); &#125; if(id == &apos;&apos; || id == undefined || jobDesc == &apos;&apos; || jobDesc == undefined)&#123; $A(&apos;#jobId&apos;).combobox(&apos;setValue&apos;,&apos;0&apos;); $A(&apos;#jobId&apos;).combobox(&apos;setText&apos;,&apos;全部&apos;); &#125;&#125;, – add/updat页面combobox初始化 1234567891011121314151617181920$.ajax(&#123; url : &apos;platform/appframe/jobcenter/jobinfo/ExecutorRouteStrategyEnum.do&apos;, async:false, type : &quot;post&quot;, dataType : &quot;json&quot;, success : function(data) &#123; //js全局变量 self.executorRouteStrategyMap = data; &#125; &#125;); var ERSCurrent = data.executorRouteStrategy;$.each(self.executorRouteStrategyMap, function() &#123; if(this.val = ERSCurrent) //data 是updat的数据来源 通过data.ersTitle 让combobox初始化 val已经注入 所以需要手动对Title注入 //$A(&quot;#jobInfoPage_form&quot;).refreshFormData(data); data.ersTitle = this.ersTitle;&#125;); – XGrid按钮不同行设置disabled 123456789//可以通过shift+command+R 输入 app-grid.js中的代码 看到api 中没有的部分config.getButton(&quot;jobLogPage_grid_StopTMsg&quot;).setAttr(&quot;disabled&quot;,function(data,e)&#123; if(data.handleCode == 0 &amp;&amp; row.triggerCode == 200)&#123; return false; &#125; return true; &#125;); – Multselect-sortable(多项选择项-可手动排序) xxx.xml 1234567891011121314151617181920212223242526&lt;items&gt; &lt;Panel id=&quot;afaAppMenuPage_panel_content&quot; region=&quot;center&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;margin: 15px;&quot;&gt; &lt;items&gt; &lt;Panel id=&quot;afaAppMenuPage_panel_left&quot; region=&quot;west&quot; layout=&quot;border&quot; style=&quot;width:330px;height:510px;border:1px solid #CCC;float:left;&quot;&gt; &lt;items&gt; &lt;Tree id=&quot;afaAppMenuTree&quot; width=&quot;100%&quot; hasQry=&quot;false&quot; hasRoot=&quot;false&quot; style=&quot;overflow:scroll;&quot; idField=&quot;treeId&quot; isAsync=&quot;true&quot; nameField=&quot;treeText&quot; parentField=&quot;treeParentId&quot; height=&quot;510px&quot; loadUrl=&quot;platform/appframe/menu/afaappmenu/getAfaAppMenuTree.do&quot; checkable=&quot;false&quot; selectedMulti=&quot;true&quot;&gt; &lt;/Tree&gt; &lt;/items&gt; &lt;/Panel&gt; &lt;Panel id=&quot;afaAppMenuPage_panel_center&quot; region=&quot;center&quot; layout=&quot;border&quot; style=&quot;width:100px;height:510px;float:left;&quot;&gt; &lt;items&gt; &lt;ButtonArea id=&quot;afaAppMenuPage_panel_center-btns&quot; displayType=&quot;BUTTON&quot;&gt; &lt;Button id=&quot;btnRightward&quot; name=&quot; &gt;&gt;&quot; style=&quot;margin-top: 210px;&quot;&gt;&lt;/Button&gt; &lt;/ButtonArea&gt; &lt;/items&gt; &lt;/Panel&gt; &lt;Panel id=&quot;afaAppMenuPage_panel_right&quot; region=&quot;right&quot; layout=&quot;border&quot; style=&quot;width:330px;height:510px;border:1px solid #CCC;float:left;overflow:scroll;&quot;&gt; &lt;items&gt; &lt;/items&gt; &lt;/Panel&gt; &lt;/items&gt; &lt;/Panel&gt;&lt;/items&gt; xxx.jsp 12345678&lt;style&gt; #afaAppMenuPage_panel_right&#123;border-left: 1px solid #cbcbcb&#125; #afaAppMenuPage_panel_right &gt; .tag-list&#123;width: 90%; margin: 10px auto 0;&#125; #afaAppMenuPage_panel_right &gt; .tag-list &gt; li,#afaAppMenuPage_panel_right &gt; .tag-list &gt; li &gt; span &#123;width: 100%&#125; #afaAppMenuPage_panel_right &gt; .tag-list &gt; li &gt; span &#123;text-align: center&#125; #afaAppMenuPage_panel_right &gt; .tag-list &gt; li.icon-shanchutianchong::before&#123;cursor:pointer&#125;&lt;/style&gt; requireJs: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//获得容器getContainer : function()&#123; var $div = $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list&quot;); if($div != null &amp;&amp; $div != &quot;undefined&quot; &amp;&amp; $div.length &gt; 0)&#123; &#125;else&#123; $div = &quot;&lt;ul class=&apos;tag-list&apos;&gt;&lt;/ul&gt;&quot;; $A(&quot;#afaAppMenuPage_panel_right&quot;).append($div); &#125; $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list&quot;).sortable(&#123; &quot;handle&quot;:&quot;span&quot;, &quot;start&quot;:function(e,ui)&#123; ui.item.addClass(&quot;curr&quot;); &#125;, &quot;stop&quot;:function(e,ui)&#123; ui.item.removeClass(&quot;curr&quot;); &#125; &#125;); $( &quot;#afaAppMenuPage_panel_right&quot; ).disableSelection();&#125;,//新增菜单选项insertUserMenu: function(treeNode)&#123; var $porlet = $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list &gt; li&quot;); var $po = $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list span[rel=&quot;+ treeNode.treeId +&quot;]&quot;); if($po != null &amp;&amp; $po != &quot;undefined&quot; &amp;&amp; $po.length &gt; 0)&#123; $a.messager.error(&quot;该菜单已选择&quot;); return false; &#125; var $userMenu = AfaShortCutMenuDlg.getInstance().setUserMenu(treeNode.treeId,treeNode.treeText); AfaShortCutMenuDlg.getInstance().getContainer(); $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list&quot;).append($userMenu);&#125;,//设置门户setUserMenu: function(key,value)&#123; var style=&quot;&quot;; var div = &quot;&lt;li style=&apos;border-radius: 5px;margin-bottom:5px;border: 1px solid #cecece;padding: 5px;text-align: center;&apos;&apos;&gt;&lt;span style=&apos;font-size:12px;&apos; href=\&quot;javascript:void(0)\&quot; rel=&quot;+ key +&quot; name=\&quot;&quot;+ value +&quot;\&quot;&gt;&lt;span class=\&quot;icon-shanchutianchong\&quot; style=\&quot;display:inline-block;height:1.3em;width:1em;margin-right:.4em;cursor:pointer;\&quot;&gt;&lt;/span&gt;&quot;+ value +&quot; &lt;/span&gt;&lt;/li&gt;&quot;; return div;&#125;,doSave : function(config, callback) &#123; var $userMenu = $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list &gt; li &gt; span&quot;); if($userMenu.length==0)&#123; alert(&quot;请选择授权对象&quot;); return false; &#125; var menuIdString=&quot;&quot;; for(var i=0;i&lt;$userMenu.length;i++)&#123; var obj=&#123;&#125;; menuIdString += $($userMenu[i]).attr(&quot;rel&quot;)+&quot;,&quot;; &#125; menuIdString = menuIdString.substring(0,menuIdString.length-1); var url = &quot;platform/appframe/menu/afashortcutmenu/batchAddShortcutMenu.do&quot;; $app.ajax.ajaxCall(&#123; url: url, data: &#123;menuIds: menuIdString&#125;, callback: function()&#123; $a.messager.correct(&quot;操作成功&quot;); &#125; &#125;); /*if (_self.showPageCallBack) &#123; _self.showPageCallBack(); &#125;*/ $.closeDialog();&#125;,// 页面加载后初始化initPage : function() &#123; var url = &quot;platform/appframe/menu/afashortcutmenu/getShortcutMenuByUserCode.do&quot;; $app.ajax.ajaxCall(&#123; url: url, data: &#123;&#125;, callback: function(data)&#123; console.log(data); for(var i=0;i&lt;data.length;i++)&#123; var $userMenu = AfaShortCutMenuDlg.getInstance().setUserMenu(data[i].menuId,data[i].menuName); AfaShortCutMenuDlg.getInstance().getContainer(); $A(&quot;#afaAppMenuPage_panel_right &gt; .tag-list&quot;).append($userMenu); &#125; &#125; &#125;); $(&quot;#afaAppMenuPage_panel_right&quot;).click(function(e)&#123; console.log(event.target.className.indexOf(&apos;icon-shanchutianchong&apos;)) if (e.target.tagName.toLowerCase() === &quot;span&quot; &amp;&amp; e.target.className.indexOf(&apos;icon-shanchutianchong&apos;) !== -1) &#123; $(e.target.parentElement.parentElement).remove() &#125; &#125;); &#125;,]]></content>
      <categories>
        <category>BS前端页面汇总</category>
      </categories>
      <tags>
        <tag>BS前端页面汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进入BS部门第一天]]></title>
    <url>%2F2017%2F09%2F20%2F%E9%83%A8%E9%97%A8%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[摘要: 遇到问题及解决 遇到问题及解决 web项目出现Dynamic Web Module 无法从2.3转化为2.5的版本。 解决方案：首先出现问题的原因在于你的web.xml： 1234&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee&quot;xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; 项目还是2.3的，而使用的version=2.5的，项目会报错（大致的意思就是无法转化），可以通过在本地项目中.setting文件中进行手动改变为2.5。 引用的项目来自gitlab上，gitlab所引用的项目已经在gitlab上已经更新的，但是在maven repository中的还未改变。 解决方案：可以通过将gitlab上的项目下载下来，然后进行install 生成新的jar包或者其他的包 其中用到的操作： git init git clone gitLab地址 cd 对应的项目中 mvn clean install 生成最新的jar包或其他包 将项目也导入进eclipse中，原本引用该gitlab上的项目优先在本地上进行搜索并且加载，如果没有在从远程repository中下载对应的包。]]></content>
      <categories>
        <category>遇到问题及解决</category>
      </categories>
      <tags>
        <tag>遇到问题及解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac_eclipse调制代码方式]]></title>
    <url>%2F2017%2F09%2F20%2Feclipse%E8%B0%83%E5%88%B6%E4%BB%A3%E7%A0%81%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[摘要: mac_eclipse调制代码方式 调制代码时，常用到的方式shift + command + T -&gt; Open Type control + H -&gt; Search (File Search、Java Search …) command + O -&gt; 查看该class中的方法和成员变量 command + e -&gt; 快速转换编辑器 option + command + 上下 -&gt; 将高亮显示处往上或下复制 command + m -&gt; 窗口最大化切换 command + / -&gt; 自动注释掉选择的代码块 command + shift + / -&gt; 自动注释掉选择的代码块 command + shift + X 和 command + shift + Y -&gt; 英文字母大小写的转换 command +shift + O -&gt; 自动引入包和删除无用包 command +option + 左右 -&gt; 回到上次光标的位置 debug模式情况下：想立刻执行一条语句刚写的语句，此时断点正在附近: command + U 左边的是将所有包缩小 右边勾选 会自动跟从你所浏览的代码所在的包的位置 Projects Presentation(项目介绍)展示方式： Flat（平坦式 一大串）； Hierarchical（分等级式 像ztree的感觉） Variables 可以在debug时看到对应的变量的情况BreakPoints 可以在这里看到你打得断点的信息（位置，数量，也可以对端点进行操作）Expressions 在端点执行过程中 执行想要的方法 对Tomcat进行部分操作修改Servers中某个Tomcat的config(后台代码修改不会导致Tomcat重启) server.xml： 修改最后几行的 Context标签中 reloadable=”false” debug=”0” 现在有个很好用的插件不需要上面的配置就可以实现 后台代码修改即可以使用，不需要重启Tomcat。JRebel 支持 eclipse、Intelli IDEA、android studio 对Git进行操作 Commit的操作然后Pull（更新）Push（提交git合并） 对Maven包依赖查看]]></content>
      <categories>
        <category>mac_eclipse调制代码方式</category>
      </categories>
      <tags>
        <tag>mac_eclipse调制代码方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小组项目学习记录]]></title>
    <url>%2F2017%2F09%2F12%2FBS%E5%B0%8F%E7%BB%84%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[摘要: BS小组项目学习记录 前端部分（XML、JS）前端使用到公司的框架： xml标签：Page、items、Panel、Tree、XGrid…JS使用到的是requireJS： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//define([&apos;引入外部js模块或控件&apos;],function(&apos;引入外部js或控件的别名&apos;)&#123;&#125;)define([&quot;app/widgets/window/app-dialog&quot;,&quot;目录&quot;,&quot;目录&quot;],function(Dialog,PageBase,dlg)&#123; var xxxModel = PageBase.extend(&#123; //类初始化 initialize : function()&#123; xxxModel.superclass.initialize.call(this); &#125;, //控件监听事件 格式：#控件id#:&#123;事件名:事件方法&#125; listeners:&#123; &#125;, //页面初始化 initPage:function()&#123; &#125;, //显示查看业 showViewPage:function(data,e)&#123; var _self=this; dlg.showPage(dlg.ACTION.VIEW,data,function()&#123; _self.refreshData(); &#125;); &#125;, refreshData:function()&#123; $(&quot;#receiptMaintenancePage_grid&quot;).grid(&quot;reload&quot;); &#125;, //显示编辑业 showEditPage:function(data,e)&#123; var _self=this; dlg.showPage(dlg.ACTION.EDIT,data,function()&#123; //_self.refreshData(); $(&quot;#receiptMaintenancePage_grid&quot;).grid(&quot;reload&quot;); &#125;); &#125;, //控件属性重置 initUIExtConfig : function() &#123; var _self=this; this.uiExtConfig=&#123; //格式 #控件id#:function(控件属性集类)&#123; config.setAttr(&quot;控件属性名&quot;,&quot;属性值&quot;),// 网格，下拉网格，特殊设置config.getColumn(&quot;网列id&quot;).setAttr(&quot;列属性名&quot;,&quot;列属性值&quot;)config.getButton(&quot;网格内包含的按钮id&quot;).setAttr(&quot;handler&quot;,&quot;点击事件&quot;) &#125; receiptMaintenancePage_grid:function(config)&#123; config.getButton(&quot;receiptMaintenancePage_grid_btnEdit&quot;).setAttr(&quot;handler&quot;,_self.showEditPage); config.getButton(&quot;receiptMaintenancePage_grid_btnView&quot;).setAttr(&quot;handler&quot;,_self.showViewPage); config.getButton(&quot;receiptMaintenancePage_grid_btnDel&quot;).setAttr(&quot;handler&quot;,_self.doDeleteData); &#125; &#125; &#125; &#125;); xxxModel.getInstance=function()&#123; if (!this.instance)&#123; this.instance =new xxxModel(); &#125; return this.instance; &#125; return xxxModel.getInstance();&#125;); XML经常使用到的方式1.树 123456&lt;Tree id=&quot;receiptLeftTree&quot; layoutHeight=&quot;0&quot; width=&quot;100%&quot; hasRoot=&quot;true&quot; rootId=&quot;&quot; rootName=&quot;机构列表&quot; idField=&quot;treeId&quot; isAsync=&quot;true&quot; nameField=&quot;treeText&quot; parentField=&quot;treeParentId&quot; hasQry=&quot;true&quot; searchUrl=&quot;platform/appframe/afauser/searcherAfaUserTree.do&quot; searchFields=&quot;orgName&quot; loadUrl=&quot;platform/appframe/afauser/queryAfaUserTree.do&quot;&gt;&lt;/Tree&gt; 2.查询功能 12345678910111213141516171819&lt;Query id=&quot;receiptMaintenancePage_query&quot; queryTarget=&quot;receiptMaintenancePage_grid&quot; isAdvance=&quot;true&quot; style=&quot;display:none;&quot; manual=&quot;false&quot; advColCount=&quot;2&quot;&gt; &lt;quicks&gt; &lt;QueryItem id=&quot;ticketedPointCode&quot; name=&quot;开票点&quot; tips=&quot;输入开票点编码查询&quot; field=&quot;TICKETED_POINT_CODE&quot; operator=&quot;like&quot; editorType=&quot;TEXTBOX&quot; /&gt; &lt;QueryItem id=&quot;startTime&quot; name=&quot;编制日期&quot; field=&quot;CREATE_TIME&quot; tips=&quot;输入编制日期查询&quot; operator=&quot;&gt;=&quot; editorType=&quot;DATETIME&quot; /&gt; &lt;QueryItem id=&quot;endTime&quot; name=&quot;至&quot; field=&quot;CREATE_TIME&quot; tips=&quot;输入编制日期查询&quot; operator=&quot;&amp;lt;=&quot; editorType=&quot;DATETIME&quot; /&gt; &lt;QueryItem id=&quot;gaoji&quot; name=&quot;高级&quot; value=&quot;1&quot; visible=&quot;false&quot; operator=&quot;=&quot; editorType=&quot;TEXTBOX&quot; /&gt; &lt;/quicks&gt; //高级查询 &lt;advances&gt; &lt;QueryItem id=&quot;ticketedPointCode&quot; name=&quot;开票点编码&quot; editorType=&quot;TEXTBOX&quot; /&gt; &lt;QueryItem id=&quot;createTime&quot; name=&quot;创建日期&quot; editorType=&quot;DATETIME&quot; /&gt; &lt;/advances&gt;&lt;/Query&gt; 3.标签页 123456789101112131415161718192021&lt;Panel id=&quot;id必填&quot; region=&quot;定义布局面板的位置&quot;&gt; &lt;items&gt; &lt;Tabs id=&quot;receiptMaintenance_panel_right_bottom_tabs&quot;&gt; &lt;items&gt; &lt;TabPanel id=&quot;panel_south_tabs_projects_info&quot; name=&quot;项目&quot; layout=&quot;border&quot; style=&quot;height: 240px;&quot;&gt; &lt;items&gt; 内容可以是 XGrid或者Form &lt;/items&gt; &lt;/TabPanel&gt; &lt;TabPanel id=&quot;panel_south_tabs_user_info&quot; name=&quot;项目&quot; layout=&quot;border&quot; style=&quot;height: 240px;&quot;&gt; &lt;items&gt; 内容可以是 XGrid或者Form &lt;/items&gt; &lt;/TabPanel&gt; &lt;/items&gt; &lt;/Tabs&gt; &lt;/items&gt;&lt;/Panel&gt; 4.XGridColumn实现下拉并且将row自动填写( XML 和 JS(在listeners中) ) 4.1 XML: 12345678&lt;XGridColumn field=&quot;projectStandard&quot; title=&quot;项目标准&quot; editorType=&quot;COMBOBOX&quot; align=&quot;center&quot; editorOptions=&quot;&#123; textfield: &apos;projectStandard&apos;, valuefield: &apos;projectCode&apos;, url: &apos;platform/appframe/receipt/maintenance/receiptmaintenance/queryProjectList.do&apos; &#125;&quot; /&gt; 4.2 JS: 12345678910111213141516171819projects_grid_editable : &#123; onClickCell : function(rowData, rowIndex, field) &#123; var self = ReceiptMaintenanceDlg.getInstance(); if(field == &quot;projectStandard&quot;)&#123; var edProjectStandard = $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, field); var edProjectCode = $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, &quot;projectCode&quot;); $(edProjectStandard).combobox(&apos;reload&apos;,&apos;platform/appframe/receipt/maintenance/receiptmaintenance/queryProjectList.do?whichData=project&apos;); $(edProjectStandard).bind(&apos;change&apos;,function()&#123; var projectId = $(edProjectStandard).combobox(&quot;getValue&quot;); var projectStandard= $(edProjectStandard).combobox(&quot;getText&quot;); var rowIndex = $(&apos;#projects_grid_editable&apos;).grid(&apos;getCurrentEditRowIndex&apos;); var rowData = $(&apos;#projects_grid_editable&apos;).grid(&apos;getCurrentEditRowData&apos;); $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, &quot;projectCode&quot;).textbox(&apos;setValue&apos;,projectId); $(&apos;#projects_grid_editable&apos;).grid(&apos;getEditor&apos;, &quot;projectCode&quot;).textbox(&apos;disable&apos;);// $(&apos;#projects_grid_editable&apos;).grid(&apos;saveRow&apos;, &#123;rowIndex : rowIndex, rowData:&#123;&apos;projectCode&apos;:projectId&#125;, command:&apos;update&apos;&#125;); &#125;); &#125; &#125;&#125; 5.将主表的数据和副表的数据一起发送给后台(增删改) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556doSave : function(config, callback) &#123; var gridData = $(&quot;#projects_grid_editable&quot;).grid(&apos;getAllData&apos;); var params = $A(&apos;#receiptMaintenancePage_form&apos;).getSumbitData(); var obj = new Object(); obj.gridData = gridData; obj.mainData = params.data; obj.type = &quot;modify&quot;; var myURL = &quot;platform/appframe/receipt/maintenance/receiptmaintenance/doInsertProject.do&quot;; $app.ajax.ajaxCall(&#123; url : myURL, data : obj, contentType:&apos;application/json&apos;, dataType: &apos;json&apos;, type: &apos;POST&apos;, callback : function(json) &#123; if (config.isSaveAdd) &#123; $A(&quot;#receiptMaintenancePage_form&quot;) .clearFormEditorValue(); _self.indexAction = _self.ACTION.ADD; &#125; else if (config.isSaveClose) &#123; $.closeDialog(); _self.indexAction = &quot;&quot;; &#125; else if (config.isSaveView) &#123; $A(&quot;#receiptMaintenancePage_form&quot;) .toggleFormState(&quot;view&quot;); $A(&quot;#id&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#ticketedPointCode&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#ticketedPointName&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#ticketedPointType&quot;).combobox(&quot;readonly&quot;, true); $A(&quot;#simpleCode&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#dataAcquisitionCycle&quot;).textbox(&quot;readonly&quot;, true);// $A(&quot;#createTime&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#sysAppMode&quot;).combobox(&quot;readonly&quot;, true); $A(&quot;#contacts&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#contactsInfo&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#superOrg&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#isOnline&quot;).textbox(&quot;readonly&quot;, true); $A(&quot;#remark&quot;).textbox(&quot;readonly&quot;, true); // $A(&quot;#sysAppMode&quot;).combobox(&quot;readonly&quot;, true); // $A(&quot;#sysAppModeRadioBox&quot;).radiobox(&quot;readonly&quot;, false);// $A(&quot;#emergencyTicketed&quot;).radiobox(&quot;readonly&quot;, false);// $A(&quot;#emergencyDays&quot;).textbox(&quot;readonly&quot;, false); _self.indexAction = _self.ACTION.VIEW; &#125; if (_self.showPageCallBack) &#123; _self.showPageCallBack(); &#125; &#125; &#125;);&#125; 6.小表的操作 1234567891011121314151617181920initUIExtConfig : function() &#123; var _self = this; this.uiExtConfig = &#123; // 格式 #控件id#:function(控件属性集类)&#123; config.setAttr(&quot;控件属性名&quot;,&quot;属性值&quot;),// // 网格，下拉网格，特殊设置config.getColumn(&quot;网列id&quot;).setAttr(&quot;列属性名&quot;,&quot;列属性值&quot;)config.getButton(&quot;网格内包含的按钮id&quot;).setAttr(&quot;handler&quot;,&quot;点击事件&quot;) // &#125; projects_grid_editable:function(config)&#123; config.getButton(&quot;projects_grid_addBtn&quot;).setAttr(&quot;handler&quot;, _self.appendPGridRow); config.getButton(&quot;projects_grid_deleteBtn&quot;).setAttr(&quot;handler&quot;, _self.deletePGridRow); &#125;, receipts_grid_editable:function(config)&#123; config.getButton(&quot;receipts_grid_addBtn&quot;).setAttr(&quot;handler&quot;, _self.appendRGridRow); config.getButton(&quot;receipts_grid_deleteBtn&quot;).setAttr(&quot;handler&quot;, _self.deleteRGridRow); &#125;, users_grid_editable:function(config)&#123; config.getButton(&quot;users_grid_addBtn&quot;).setAttr(&quot;handler&quot;, _self.appendUGridRow); config.getButton(&quot;users_grid_deleteBtn&quot;).setAttr(&quot;handler&quot;, _self.deleteUGridRow); &#125; &#125;&#125; 前后台请求1.其中BS使用到的ajax自带的方式 123456789101112131415161718192021222324252627前端JS：$app.ajax.ajaxCall(&#123; url : url, data : jsonData, callback : function(data) &#123; $(&quot;#receiptMaintenancePage_grid&quot;).grid(&quot;reload&quot;); &#125;&#125;);后台controller:public AajaxResult queryProect(@requestBody 对象 对象名)&#123;&#125;需要注意的是：Json格式：&#123; mainData:&#123;id:&apos;&apos;,name:&apos;&apos;&#125;, gridData:[&#123;gId:&apos;&apos;,gName:&apos;&apos;&#125;,&#123;gId:&apos;&apos;,gName:&apos;&apos;&#125;]&#125;pojo数据：public class myJsonRequest&#123; private Object mainData; private List&lt;Object&gt; gridData;&#125;才可以接受到 2.BS使用$.ajax({});方式 12]]></content>
      <categories>
        <category>bs学习记录</category>
      </categories>
      <tags>
        <tag>bs学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next博客进阶]]></title>
    <url>%2F2017%2F08%2F28%2Fnext%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[摘要: next添加RSS、字数统计及阅读时长、next主题修改动态背景 next添加RSS 进入本地hexo目录,输入以下命令: 1npm install hexo-generator-feed 添加配置，在本地hexo根目录下的_config.yml文件中，添加以下配置: 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 添加主题配置，在主题目录下的_config.yml目录下，添加如下配置: 1rss: /atom.xml 字数统计及阅读时长 Install 1npm install hexo-wordcount --save *修改对应的代码（blog/themes/next/layout/_macro/post.swig） &lt;span title=&quot;{{ __('post.wordcount') }}&quot;&gt; {{ wordcount(post.content) }} 字 &lt;/span&gt; &lt;span title=&quot;{{ __('post.min2read') }}&quot;&gt; {{ min2read(post.content) }} 分钟 &lt;/span&gt; next主题修改动态背景(这里只说next主题在5.1.1以上版本) 在对应的目录下修改(blog/themes/next/_config.yml)自行尝试 123456789101112131415# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribboncanvas_ribbon: true 参考的网站：Hexo文章计数插件WordCounthexo博客安装RSS插件next主题如何添加动态背景]]></content>
      <categories>
        <category>next进阶</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站框架初识]]></title>
    <url>%2F2017%2F08%2F28%2F%E7%BD%91%E7%AB%99%E6%A1%86%E6%9E%B6%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[摘要: 网站框架初识，其中框架的演变和技术 网站框架初识 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 待续… 参考的网站：dubbo]]></content>
      <categories>
        <category>网站框架初识</category>
      </categories>
      <tags>
        <tag>网站框架初识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初步了解Redis和ZooKeeper]]></title>
    <url>%2F2017%2F08%2F28%2F%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3Redis%E5%92%8CZookeeper%2F</url>
    <content type="text"><![CDATA[摘要: 初步了解Redis和ZooKeeper作用及使用场景;mac依赖brew快速安装Redis和ZooKeeper RedisRedis是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的Web应用程序。(键值对 key-value) Redis有三个主要特点，使它优越于其它键值数据存储系统: Redis将其数据库完全保存在内存中，仅使用磁盘进行持久化。 与其它键值数据存储相比，Redis有一组相对丰富的数据类型。 Redis可以将数据复制到任意数量的从机中。 Redis的优点 异常快 - Redis非常快，每秒可执行大约 ==110000== 次的设置( ==SET== )操作，每秒大约可执行81000次的读取/获取( ==GET== )操作。 支持丰富的数据类型 - Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得Redis很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。 操作具有原子性 - 所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新的值。 多实用工具 - Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。 “原子操作(atomic operation)是不需要synchronized”，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程） —- 度娘 Redis与其他键值存储系统 Redis是键值数据库系统的不同进化路线，它的值可以包含更复杂的数据类型，可在这些数据类型上定义原子操作。 Redis是一个内存数据库，但在磁盘数据库上是持久的，因此它代表了一个不同的权衡，在这种情况下，在不能大于存储器(内存)的数据集的限制下实现非常高的写和读速度。 内存数据库的另一个优点是，它与磁盘上的相同数据结构相比，复杂数据结构在内存中存储表示更容易操作。 因此，Redis可以做很少的内部复杂性。 ZooKeeper 首先需要了解分布式系统（distributed system） 建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。在分布式数据库系统中，用户感觉不到数据是分布的，即用户不须知道关系是否分割、有无副本、数据存于哪个站点以及事务在哪个站点上执行等。 内聚性是指每一个数据库分布节点高度自治，有本地的数据库管理系统。 透明性是指每一个数据库分布节点对用户的应用来说都是透明的，看不出是本地还是远程。 了解分布式协调技术 主要用来解决分布式环境当中多个进程之间的同步控制，让他们有序的去访问某种临界资源，防止造成”脏数据”的后果。 分布式协调技术的核心就是实现分布式锁 顺带提下mac上安装Redis和ZooKeeper很快捷（需要已经安装过 ==Homebrew== ）[Homebrew官方](https://brew.sh/) 123456789安装 Homebrew ：/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;安装 Redis ：brew install redis安装 ZooKeeper ：brew install zookeeper 参考网站 Redis快速入门 ZooKeeper学习第一期—Zookeeper简单介绍]]></content>
      <categories>
        <category>Redis &amp; ZooKeeper</category>
      </categories>
      <tags>
        <tag>Redis &amp; ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github命令]]></title>
    <url>%2F2017%2F08%2F28%2Fgithub%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[摘要: github命令 github使用的基本步骤 mac环境1、 创建一个Test文件夹，然后进去到此文件夹中(初始化git仓库) 1git init 2、 git clone 命令将存储库克隆到新目录中 12git clone http://bogon/huangdonghua/mytest.git输入对应的账号密码 3、 查看状态 1git status 4、 把 myTest/test.txt 文件添加到本地Git仓库，将myTest一并add 1git add myTest/ 5、 可以选择设置下自己的用户名与邮箱 12git config —global user.name &quot;huangdonghua&quot; git config —global user.email &quot;591327356@qq.com&quot; 6、 正式提交 1git commit -m ‘myTest’ 7、 查看所有产生的 commit 记录 1git log 8、 把本地 Test 项目与 GitLab 上的 myTest 项目进行关联（切换到Test 目录） 123git remote add origin http://bogon/huangdonghua/mytest.gitgit remote -v //查看我们当前项目有哪些远程仓库 9、 向远程仓库进行代码提交 (需要事先配置好公钥和密钥 id_rsa.pub 和 id_rsa) 1git push origin master 出现过的错误: 123456789$ git push origin master To http://bogon/huangdonghua/mytest.git ! [rejected] master -&gt; master (fetch Mytest) error: failed to push some refs to &apos;http://bogon/huangdonghua/mytest.git&apos; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &apos;git pull ...&apos;) before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 理解： 远程仓库已经更新了，本地仓库还未更新，在 push 之前需要做 pull 用来更新本地仓库（保证一致，才可以进行合并) 1git pull origin master 这时候又有可能遇到的问题： 1234$ git pull origin master From http://bogon/huangdonghua/mytest.git * branch master -&gt; FETCH_HEAD fatal: refusing to merge unrelated histories 解决方案：1git pull origin master --allow-unrelated-histories 成功后，就可以执行 push 操作了 在mac下 SSH Key设置： 1234567$ cd ~/.ssh/$ ls如果看到 id_rsa id_rsa.pub 这2个文件就说明已经有了SSH Key；这时候只要 vim id_rsa.pub 赋值就可以了如果没有： ssh-keygen -t rsa 选择默认和输入密码就可以省下就和上面一样了 其余git命令123456789101112131415161718git branch aaa 新建分枝aaa git branch 查看分枝 git checkout aaa 切换到分枝aaa git checkout -b aaa 新建并切换到aaa git merge aaa 把aaa分支的代码合并过来(当前所在分枝，比如master) git branch -d aaa 删除分枝aaa git branch -D aaa 强制删除aaa git tag v1.0 加版本号 git tag 查看版本号 git checkout v1.0 切换到版本v1.0//恢复某个文件的修改，若存在暂存区域的话，就恢复到暂存区域的状态，//若不存在暂存区域的话，就恢复到本地库的状态。git checkout 文件名//下面的.是表示所有文件git checkout .//若存在暂存区域，就是工作区与暂存区域的具体差异，若不存在暂存区域，则是工作区与本地库的具体差异。git diff 懒人避免冲突的方式：先将本地修改存储起来 1$ git stash 这样本地的所有修改就都被暂时存储起来 123$ git stash listgit stash暂存修改其中stash@&#123;0&#125;就是刚才保存的标记。 暂存了本地修改之后，就可以pull了 1$ git pull 还原暂存的内容 1$ git stash pop stash@&#123;0&#125; 详细懒人方式]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetbrains软件(WS、IJ)]]></title>
    <url>%2F2017%2F08%2F28%2F%E7%A0%B4%E8%A7%A3Jetbrains%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[摘要: 破解Jetbrains软件 Ubuntu下面 PHPSTORM2017.2破解方法 在 http://idea.lanyus.com/上面新下载一个破解文件。 破解步骤 将JetbrainsCrack-2.6.3_proc.jar放到phpstorm安装目录的lib文件夹下面 进入到phpstorm安装目录的bin目录下面。找到phpstorm64.vmoptions文件，然后打开，在最后面一行输入-javaagent:/opt/phpstorm2017/lib/JetbrainsCrack-2.6.3_proc.jar保存文件。 打开http://idea.lanyus.com/getkey?userName=username username可以随便更改成你想要的，然后生成一个激活码， 再打开phpstorm，选择Activation Code选项，将生成的激活码复制进去，然后激活。 完结 重启phpstorm，然后就可以开始coding之路了。]]></content>
      <categories>
        <category>Jetbrains</category>
      </categories>
      <tags>
        <tag>Jetbrains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macdown操作手册]]></title>
    <url>%2F2017%2F08%2F28%2Fmacdown%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[摘要: 认识MarkDown 一、认识MarkDown什么是 MarkDown ? MarkDown 是一种 轻量级的标记语言 ,可以使用普通文本编辑器编写的语言。通过简单的标记语法，使普通的文本具有一定的格式。 MarkDown 的优点在于，它用简洁的语法代替了排版。而不像一般我们用的处理软件 Word或 Pages 有大量的排版、字体设置。它使我们专注于内容的编写。 MarkDown 不仅支持文字排版，还支持插入 图片，连接 ，视频，音频 等。而这些操作我们都可以只用键盘完成。 MarkDown 优点 使我们专注于内容，而不用再去使用鼠标进行排版 可以导出为 PDF、 HTML以及.md 本身的格式文件。 上手简单 二、 MacDown编辑器 在线 MacDown编辑器 现在多个 论坛或者博客都支持markdown 语法，例如：CSDN、 简书等。 MAC系统专用的MarkDown编辑器为 MacDown 下载地址:http://macdown.uranusjr.com MacDown 是一款即简单又容易使用的 MarkDown编辑器。 MacDown即可以把 内容导出为 HTML文件 、PDF文件，还可以实时预览。 比如：左边是 内容，右边是 实时预览。 macDown特性 支持原始的 MarkDown语言，并且有更多功能 支持实时预览 三、常用语法换行 在 markdown 语法中，使用两个空格 + 回车换行 空格 空格 +回车 或者 使用两个回车换行 回车回车 标题 标题有两种方式 使用文字 + 一行= 号，表示1级标题，文字 +一行 ---减号，2级标题 使用文字 + 多个#号 标题使用 文字 1行等号 表示1级标题文字 ------- 1行减号 表示2级标题 标题1或者 标题1通常我们使用 #号，来标记 标题等级。如下所示： Header 1Header 2Header 3Header 4Header 5Header 6文本样式 粗体**粗体** 粗体 斜体*斜体* 删除线~~删除线~~需要设置偏好设置 preferences-&gt;MarkDown-&gt;Strikethrough ==高亮====高亮==需要支持高亮 preferences-&gt;MarkDown-&gt;highlight 段落段落与 段落之间一定要空一行 水平线-- 两个减号表示实线，--- 三个减号表示虚线 – 图片 插入图片格式： ![图片说明](图片链接) 图片链接可以为本地链接，也可以为 网络链接。 本地链接，需要在 ( )小括号里面需要填写图片在本地的地址。 本篇文章MarkDown介绍.md路径 和图片 avatar.jpg所在文件夹在同一个路径下,因此先使用点. 号获取当前路径，然后使用./images 获取图片文件夹路径，进一步获取图片路径 图片路径: ./images/avatar.jpg 例如：本地图片 如果是 网络图片链接，小括号里面直接填写图片的网络链接即可。 例如：网络图片 引用 引用内容使用 右尖括号&gt; + 文字， 支持多级引用使用多个 右尖括号&gt;，表示多级引用。 这里是引用内容 二级引用 三级引用 插入代码 markdown 支持插入代码，使用 三个上点号 ```开头，和三个上点号结尾 ```。代码放在中间，例如： 1NSLog(@&quot;这里是插入的代码&quot;); 插入表格 mardown 插入表格，使用以下语法: | 列名 | |:----:|水平排列模式。 | :-- |居左， | :---: |居中, | ---: |居右。 12345| 列1 |列2 | 列3 ||:--- |:---:|---:|| 居左 |居中 | 居右| | 单元格1 |单元格列2 | 单元格列3 ||:— |:—: |—: || 居左 |居中 | 居右 | 插入视频 markdown 支持 html语法，因此可以通过&lt;iframe&gt; &lt;/iframe&gt;标签插入视频。 1&lt;iframe height= 600 width= 100% src=&quot;http://www.bilibili.com/video/av2993071/&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 常见格式和 快捷键 ==MarkDown 常见格式和 快捷键:== ==MacDown 常用快捷键:==]]></content>
      <categories>
        <category>macdown操作手册</category>
      </categories>
      <tags>
        <tag>macdown</tag>
      </tags>
  </entry>
</search>
